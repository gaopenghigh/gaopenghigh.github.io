<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2017-07-20T14:33:18+08:00</updated><id>//</id><title type="html">做美好的人，做酷的事</title><subtitle>记录所学所想
</subtitle><entry><title type="html">Cloud Design Patterns 学习笔记</title><link href="/tech/2017/07/20/Cloud_Design_Patterns%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="Cloud Design Patterns 学习笔记" /><published>2017-07-20T14:30:00+08:00</published><updated>2017-07-20T14:30:00+08:00</updated><id>/tech/2017/07/20/Cloud_Design_Patterns%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/tech/2017/07/20/Cloud_Design_Patterns%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html">&lt;p&gt;写于 2016-12-21 。&lt;/p&gt;

&lt;h2 id=&quot;cloud-design-patterns-&quot;&gt;Cloud Design Patterns 学习笔记&lt;/h2&gt;

&lt;p&gt;微软发布了 “&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn568099.aspx&quot;&gt;Cloud Design Patterns: Prescriptive Architecture Guidance for Cloud Applications&lt;/a&gt; “。
书中，针对云应用总结出了多种设计模式和 Guidance 。本文简要记录一下这些 pattern 和 guidance 的思想。&lt;/p&gt;

&lt;h2 id=&quot;patterns&quot;&gt;Patterns&lt;/h2&gt;

&lt;h3 id=&quot;ambassador-pattern&quot;&gt;Ambassador Pattern&lt;/h3&gt;

&lt;p&gt;对于遗留服务，它们可能缺少一些我们需要的功能，但我们又离不开它们所提供的的服务。同时这些遗留服务往往都不方便进行改造。
这时候就可以使用 Ambassador Patter，在客户端和服务端之间加一个“代理”，把原来的服务包装起来，提供我们需要的额外功能，比如重试、断路、监控、安全等等。&lt;/p&gt;

&lt;p&gt;当然，加一个“代理”会代理更多的成本，有时候提供一个客户端的类库会是更好的方式。&lt;/p&gt;

&lt;h3 id=&quot;anti-corruption-layer-pattern&quot;&gt;Anti-Corruption Layer Pattern&lt;/h3&gt;

&lt;p&gt;这个模式也是适用于遗留服务。简单地说就是在新服务和遗留服务之间建立一个转换层，所谓的 Anti-Corruption Layer。通过这一层保证新服务设计的干净，同时又能继续使用遗留服务，知道遗留服务都改造完成。&lt;/p&gt;

&lt;h3 id=&quot;backends-for-frontends-pattern&quot;&gt;Backends for Frontends Pattern&lt;/h3&gt;

&lt;p&gt;即为每一种前端，建立专门的后端服务，这些后端服务又依赖同一套基础服务。
好处是可以针对某种前端方便灵活地提供一些专有功能，而无需考虑其他前端的情况。
代价显然是架构更复杂、模块更多、成本更大。&lt;/p&gt;

&lt;h3 id=&quot;bulkhead-pattern&quot;&gt;Bulkhead Pattern&lt;/h3&gt;

&lt;p&gt;Bulkhead 就是船舱里面的隔板。这些隔板把船舱分隔成很多段，当其中一个段损坏时，海水只会灌进这一个段，而其他段仍然保持完好，船也不会因此沉没。&lt;/p&gt;

&lt;p&gt;这个模式就是把服务分成多个组，组与组之间互相隔离，一个组中的失败不会导致整体的失败。比如同一个服务部署多个集群，集群之间互相隔离，每个集群提供给特定的客户使用。&lt;/p&gt;

&lt;p&gt;客户端也可以把资源分组，比如为每个依赖的服务分配一个连接池，这样当其中一个服务不响应时，只会耗尽分配给那个服务的连接池，而不会导致整个客户端的连接耗尽。&lt;/p&gt;

&lt;p&gt;另外，讲服务分组，还可以为每个组设置优先级，优先保证重要的业务。&lt;/p&gt;

&lt;h3 id=&quot;cache-aside-pattern&quot;&gt;Cache-aside Pattern&lt;/h3&gt;

&lt;p&gt;如果一个 cache 服务没有提供 read-through 和 write-through/write-behind 的功能，比如存粹的缓存服务如
redis 或 memcached 等。可以通过 cache-aside pattern 来模拟 read-through 和
write-through/write-behind 的功能。&lt;/p&gt;

&lt;p&gt;大概的过程是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;APP 查看 cache 中是否有需要的数据，有的话直接拿到；&lt;/li&gt;
  &lt;li&gt;如果没有，就从数据存储服务中拿到这个数据；&lt;/li&gt;
  &lt;li&gt;在主动的往 cache 中存入这份数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;circuit-breaker-pattern&quot;&gt;Circuit Breaker Pattern&lt;/h3&gt;

&lt;p&gt;Circuite Breaker 就是断路器，该设计模式用来避免不必要的重试，从而避免雪崩效应。&lt;/p&gt;

&lt;p&gt;断路器有3种状态：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Closed&lt;/strong&gt;：表示断路器是接通的，即认为后端的服务都是正常的，此时请求将会被正常地提交到服务。当短时间内针对某个服务或资源的失败调用过多时，即当短期内有超过阈值的失败出现时，状态变为 Open；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Open&lt;/strong&gt;：表示断路器是断开的，即认为后端的服务出现问题了，此时请求不会提交到服务，而是直接返回失败。进入该状态时，一般会设置一个定时器，定时器到期时把断路器置为 Half-Open 状态；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Half-Open&lt;/strong&gt;：表示一种中间状态，断路器不确定后端的服务是否正常，此时会允许部分请求提交到后端，如果这些请求成功了，那就把状态设置为 Closed，否则就回到 Open 状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码实现上，可以创建一个 Circuit Breaker ，把对服务请求相关的逻辑包裹起来。如果是被断路器阻止了，则返回一种特殊的异常，做特殊的处理。&lt;/p&gt;

&lt;p&gt;一般还需要一个手工开关，可以把断路器强制设置为某种状态。&lt;/p&gt;

&lt;p&gt;在 Half-Open 状态时，除了被动地检查成功和失败数，还可以通过主动的健康检查，来决定下一步的状态。&lt;/p&gt;

&lt;h3 id=&quot;command-and-query-responsibility-segregation-cqrs-pattern&quot;&gt;Command and Query Responsibility Segregation (CQRS) Pattern&lt;/h3&gt;

&lt;p&gt;即所谓的“命令与查询职责分离”。日常经常说的“读写分离”，其实也算是 CQRS。&lt;/p&gt;

&lt;p&gt;CQRS 的核心内容是针对命令（写）和查询（读），使用不同的数据模型，最终数据也存储在不同的存储服务上。&lt;/p&gt;

&lt;p&gt;CQRS 和 Event Sourcing 模式经常结合在一起使用。
写模型就是把数据转换为 Event 存入 Event Store。
读模型就是从 Event 中读取 Event stream，转换为需要的业务结构。
这两个模式结合的缺点也很明显：读和写的延迟、额外的复杂性和处理 Event 需要的额外资源。&lt;/p&gt;

&lt;h3 id=&quot;compensating-transaction-pattern&quot;&gt;Compensating Transaction Pattern&lt;/h3&gt;

&lt;p&gt;补偿事务模式。&lt;/p&gt;

&lt;p&gt;一个事务，可能包含一系列的步骤，每个步骤需要调用不同的服务完成。
通过这一系列的步骤，整体上实现最终一致性（eventually consistent）。&lt;/p&gt;

&lt;p&gt;所谓的 Compensating Transaction Pattern 就是指，当其中的某一步失败时（经过了一些重试后），
系统自动进行一些列的补偿步骤，比如把之前已经成功的那些步骤回滚掉，实现最终一致性。
这些补偿步骤自己也是有可能会失败的，实现过程中会有一些重试，所以补偿步骤需要是幂等的。&lt;/p&gt;

&lt;p&gt;补偿步骤不一定要正好是事务步骤的逆序，而是应该根据具体业务具体实现。&lt;/p&gt;

&lt;h3 id=&quot;competing-consumers-pattern&quot;&gt;Competing Consumers Pattern&lt;/h3&gt;

&lt;p&gt;这个模式很简单，其实就是引入一个消息队列。Consumers 从队列中获取任务执行。&lt;/p&gt;

&lt;h3 id=&quot;compute-resource-consolidation-pattern&quot;&gt;Compute Resource Consolidation Pattern&lt;/h3&gt;

&lt;p&gt;业务逻辑经常包含多个任务，一般情况下，这些任务会部署在独立的计算单元中（虚拟机、容器等）。
这个模式就是把一些任务打包在一起，放在同一个计算单元中运行。
带来的好处就是能够提升资源利用率，降低成本。&lt;/p&gt;

&lt;p&gt;但是把任务放到一起，同时也可能带来新的问题，最直接的就是可能增加了复杂度。
原来解耦的任务现在放到了一起，任务之间互相影响，对于容错、安全有更高的要求，架构也变得复杂了。&lt;/p&gt;

&lt;p&gt;所以把什么样的任务放在一起，需要仔细选择。一般适用于那些对资源要求不高的，大部分时间都在等待的任务。&lt;/p&gt;

&lt;h3 id=&quot;event-sourcing-pattern&quot;&gt;Event Sourcing Pattern&lt;/h3&gt;

&lt;p&gt;一般情况下，我们会存储数据的最新状态。
Event Sourcing 模式利用 Log 的思想，把对数据的所有操作，当做一个个的 Event 存储起来。
通过订阅并且回放这些 Event，我们可以知道数据在在任何时刻的状态。&lt;/p&gt;

&lt;p&gt;Event Stream 的量可能会比较大，这时可以考虑在合适的间隔（比如每多少个 Event）时创建 snapshot。&lt;/p&gt;

&lt;p&gt;Event 的发布，很可能是“至少一次（at least once”的策略，所以订阅方需要保证 Event 的消费处理时幂等的。&lt;/p&gt;

&lt;h3 id=&quot;external-configuration-store-pattern&quot;&gt;External Configuration Store Pattern&lt;/h3&gt;

&lt;p&gt;多个 App 之间，一个 App 的多个实例之间往往需要共享配置。
这个模式就是指把配置存到一个外部的专门服务中。该服务提供接口，实现对配置的读和写。
配置服务的实现上，需要考虑很多细节问题，比如权限控制、配置的多版本、配置的数据类型等等。&lt;/p&gt;

&lt;h3 id=&quot;federated-identity-pattern&quot;&gt;Federated Identity Pattern&lt;/h3&gt;

&lt;p&gt;联合身份模式，指 App 把身份认证教给专门的 ID Provider 来进行。优点是简化了 App 的开发，提升了用户体验。&lt;/p&gt;

&lt;p&gt;常用的认证方式是“claims-based access control”：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;App/Service 信任 ID Provider（IdP)；&lt;/li&gt;
  &lt;li&gt;Client 与 IdP 练习，进行身份认证；&lt;/li&gt;
  &lt;li&gt;如果认证通过，IdP 会向 Security Token Service(STS) 返回一个 token，STS 通过该 token 能得到用户的信息（IdP 和 STS 往往是同一个服务）和用户想要的到的权限；&lt;/li&gt;
  &lt;li&gt;STS 根据预先设定的规则，对 token 进行转换，添加一些必要的信息，生成一个新的 token，然后返回给 Client；&lt;/li&gt;
  &lt;li&gt;Client 使用这个 token 来请求 App/Service；&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;gatekeeper-pattern&quot;&gt;Gatekeeper Pattern&lt;/h3&gt;

&lt;p&gt;看门人模式，就是在 App/Service 之前专门增加一个 Gatekeeper 服务，该服务做请求的合法性校验、对请求进行一些清洗（sanitizes requests），然后在 Client 和 App/Services 之间传递数据。&lt;/p&gt;

&lt;p&gt;该模式的目的在于增加一层安全性保障。&lt;/p&gt;

&lt;h3 id=&quot;gateway-aggregation-pattern&quot;&gt;Gateway Aggregation Pattern&lt;/h3&gt;

&lt;p&gt;有时候，Client 依赖多个 service，Client 需要请求这些 service 然后合并成为一个结果。
当 Client 与 Service 之间网络不够好时，这会引入严重的性能问题。&lt;/p&gt;

&lt;p&gt;Gateway Aggration Pattern 是指在 Client 和 Services 之间引入一个 Gateway，Client 发送一个请求给 Gateway，Gateway 再去请求依赖的所有服务，把这些服务的返回聚合成为一个结果，最后返回给 Client。&lt;/p&gt;

&lt;h3 id=&quot;gateway-offloading-pattern&quot;&gt;Gateway Offloading Pattern&lt;/h3&gt;

&lt;p&gt;这个模式就是把一些 Service 之间共享的特性，集中到一个新的 Gateway 层进行。
这个特性尤其适用于证书管理、鉴权、SSL termination、监控、协议转换、流量控制等等。&lt;/p&gt;

&lt;h3 id=&quot;gateway-routing-pattern&quot;&gt;Gateway Routing Pattern&lt;/h3&gt;

&lt;p&gt;就是最常见的的 Gateway 路由模式，service 不直接暴露给 client，而是统一经由 Gateway 进行路由。&lt;/p&gt;

&lt;h3 id=&quot;health-endpoint-monitoring-pattern&quot;&gt;Health Endpoint Monitoring Pattern&lt;/h3&gt;

&lt;p&gt;这是非常有用的一个模式，Service 对外暴露一个接口，可以查询当前 Service 的健康状况。&lt;/p&gt;

&lt;p&gt;要点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;返回信息的多少、实现难度以及对性能的影响，这三个方面需要有合适的的折中；&lt;/li&gt;
  &lt;li&gt;可以考虑暴露多个健康检查接口，分别检查不同重要性的健康情况；&lt;/li&gt;
  &lt;li&gt;健康检查的结果可以适当缓存，以减少对性能的影响；&lt;/li&gt;
  &lt;li&gt;健康检查接口需要考虑安全性；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;index-table-pattern&quot;&gt;Index Table Pattern&lt;/h3&gt;

&lt;p&gt;这是最常用的设计模式之一。就是为需要查询的数据生成一个索引表。&lt;/p&gt;

&lt;h3 id=&quot;leader-election-pattern&quot;&gt;Leader Election Pattern&lt;/h3&gt;

&lt;p&gt;就是常用的选主模式。大量的分布式系统都用了该模式，并且可以基于 ZooKeeper，etcd，Consul 等开源软件快速地实现 Leader Election。&lt;/p&gt;

&lt;h3 id=&quot;materialized-view-pattern&quot;&gt;Materialized View Pattern&lt;/h3&gt;

&lt;p&gt;当做数据的存储是，基于不同的存储服务，开发者考虑的往往是“写友好”，而不是“读友好”。
这就导致一些查询的请求，可能需要从存储服务读很多次，才能合并出需要的结果。&lt;/p&gt;

&lt;p&gt;该模式的思路，就是主动地生成一些方便读取查询的结果（Materialized View）。这些结果永远不会被直接更新，可以看做是一种特殊的缓存。这些缓存可能存储在完全不同的存储服务上。&lt;/p&gt;

&lt;p&gt;需要考虑的点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;什么时候去更新这些 Materialized View，一帮情况下，可以使用一个任务，或通过某种触发来生成 View。&lt;/li&gt;
  &lt;li&gt;考虑数据一致性，这是所有缓存都需要考虑的点。&lt;/li&gt;
  &lt;li&gt;考虑为 Materialized View 创建索引表，进一步优化查询性能。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;pipes-and-filters-pattern&quot;&gt;Pipes and Filters Pattern&lt;/h3&gt;

&lt;p&gt;就是把一个任务分解成一系列的小任务（Filter），然后用管道（Pipe）串联起来，数据在管道中流通。
好处是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;可以根据每一个 Filter 自身的情况为其分配资源；&lt;/li&gt;
  &lt;li&gt;利于扩展改造；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于每一个 Filter 实例可能会失败，这会导致同一份数据在 Filter 的两个实例上被执行两次，这就：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Filter 需要是幂等的。&lt;/li&gt;
  &lt;li&gt;Pipeline 需要能够检查并且去除重复消息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;该模式可以和补偿事务模式（Compensating Transaction Pattern）一起使用，来实现分布式事务。
因为一个分布式事务可以拆分成为多 Filter，每个 Filter 自身再实现补偿事务模式。&lt;/p&gt;

&lt;h3 id=&quot;priority-queue-pattern&quot;&gt;Priority Queue Pattern&lt;/h3&gt;

&lt;p&gt;对于需要区分优先级的任务的处理，可以通过引入一个优先级队列来实现。&lt;/p&gt;

&lt;p&gt;这种模式还有几个变种。&lt;/p&gt;

&lt;p&gt;第一个变种是使用多个队列，每个优先级对应一个队列。有一个 Customer Pool，里面的 Customer 总是先试图从高优先级的队列中获取任务，没有的话在尝试下一优先级的队列。&lt;/p&gt;

&lt;p&gt;第二个变种是每个优先级对应一个队列，同时还对应一个 Customer Pool，根据优先级的大小确定 Pool 的大小。&lt;/p&gt;

&lt;p&gt;第三个变种是动态地改变优先级队列中元素的优先级，随着一个元素在队列中待的时间增加，它的优先级也会逐渐增加。&lt;/p&gt;

&lt;p&gt;多队列的方式，有利于系统性能和可扩展性的最大化。&lt;/p&gt;

&lt;h3 id=&quot;queue-based-load-leveling-pattern&quot;&gt;Queue-Based Load Leveling Pattern&lt;/h3&gt;

&lt;p&gt;基于队列的负载均化模式。
就是在 Service 之前引入一个队列，作为任务的缓冲区。这样可以避免突如其来的负载高峰。
Service 根据自己的能力，按照一定的速率从队列中获取任务执行。&lt;/p&gt;

&lt;h3 id=&quot;retry-pattern&quot;&gt;Retry Pattern&lt;/h3&gt;

&lt;p&gt;就是考虑失败的情况并按照一定策略重试。
关键是根据业务情况，制定合适的重试策略。
可以联合断路器模式（Circuit Breaker pattern）一起使用。&lt;/p&gt;

&lt;h3 id=&quot;scheduler-agent-supervisor-pattern&quot;&gt;Scheduler Agent Supervisor Pattern&lt;/h3&gt;

&lt;p&gt;这个模式比较复杂，但很有用。&lt;/p&gt;

&lt;p&gt;在分布式的环境中，一个任务，经常会由一系列的步骤组成。
每一个步骤又可能依赖于某个远程服务或远程资源。
这些步骤按照一定的次序执行，只有当所有的步骤都成功时，这个任务才算作成功。&lt;/p&gt;

&lt;p&gt;Scheduler Agent Supervisor 模式包含了三种逻辑上的角色：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Scheduler 的职责是保证任务的各个步骤按照业务需要的正确顺序执行。 Scheduler 需要维护每个步骤的状态信息，包括步骤的过期时间。这些信息存放在持久型数据存储服务中，叫做 state store。如果一个步骤需要调用远程服务，则把相应的信息发送给对应的 Agent。&lt;/li&gt;
  &lt;li&gt;Agent 负责代理一个远程服务或远程资源，收到一个消息/请求后，它会根据消息的内容，调用自己代理的远程服务，然后把结果返回给 Scheduler。 Agent需要自己实现重试等机制。每一个远程服务都&lt;/li&gt;
  &lt;li&gt;Supervisor 周期性地运行，负责监控由 Scheduler 执行的所有步骤是否在规定的时间内正确完成。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Scheduler，Agent 和 Supervisor 都可以以多实例运行。不过 Supervisor 的多实例之间需要互相同步状态，或者通过 Leader Election 模式选主运行。&lt;/p&gt;

&lt;p&gt;这个设计模式的工作方式如下：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Application 需要运行一个任务时，就向 Scheduler 提交一个请求。&lt;/li&gt;
  &lt;li&gt;Scheduler 收到请求后，在 state store 中初始化该任务以及它所有步骤的状态，然后根据业务逻辑顺序来执行步骤。这些步骤必须是幂等的。&lt;/li&gt;
  &lt;li&gt;如果一个步骤依赖远程服务，Scheduler 就像对应的 Agent 发送一个消息。&lt;/li&gt;
  &lt;li&gt;Agent 收到消息后，根据其内容，调用远程服务，同时还会根据消息中的过期时间，决定是否需要终止执行。如果一切正常，Agent 会向 Scheduler 发送一个运行成功的消息。如果 Agent 没在过期时间前完成工作，则不会向 Scheduler 发送任何消息。&lt;/li&gt;
  &lt;li&gt;Supervisor 会定期检查 state store 中的所有状态，看看有哪些步骤超时了或失败了，然后尝试恢复它们。这可以通过更新步骤的过期时间，然后通知 Scheduler 实现。也可以通过 Scheduler 主动轮询 state store 实现。如果一个步骤一直失败，Supervisor 还需要知道什么时候不应该再尝试，或者进一步实现更复杂的策略。Supervisor 最本质的责任，就是当一个步骤失败是，决定是重试该步骤，还是让整个任务失败掉。&lt;/li&gt;
  &lt;li&gt;Scheduler 本身也会异常，所以当一个 Scheduler Fail 时，新的或其他的 Scheduler 需要能够恢复那些执行了一半的任务。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Scheduler Agent Supervisor 设计模式最核心的优点，就是在分布式环境下的那些临时的、意外的和不可恢复的异常情况下，整个系统是可“自恢复”的。&lt;/p&gt;

&lt;h3 id=&quot;sharding-pattern&quot;&gt;Sharding Pattern&lt;/h3&gt;

&lt;p&gt;就是常用的分片（Sharding）模式。关键是根据业务，选择合适的 Sharding 策略。&lt;/p&gt;

&lt;h3 id=&quot;sidecar-pattern&quot;&gt;Sidecar Pattern&lt;/h3&gt;

&lt;p&gt;一个 Application 可能需要一系列的附加功能，比如监控、日志、配置等等。
这些服务和 App 本身的关系不大，可以和 App 的每一个实例部署在一起。
就像边三轮摩托车的 Sidecar 一样。
容器天然适合 Sidecar 模式，每个 App 的容器都附带一个 Sidecar 容器。&lt;/p&gt;

&lt;h3 id=&quot;static-content-hosting-pattern&quot;&gt;Static Content Hosting Pattern&lt;/h3&gt;

&lt;p&gt;就是简单的动静分离模式，把静态内容放在合适的服务上。&lt;/p&gt;

&lt;h3 id=&quot;strangler-pattern&quot;&gt;Strangler Pattern&lt;/h3&gt;

&lt;p&gt;老的系统有时需要更新、升级、重构为新系统，这将是一个持续的过程。
Strangler 模式就是把新老系统都接入一个 Strangler 层，Strangler 把改造好了的接口路由给新系统，没有改造好的系统路由给老系统。当整个系统改造完成后，老系统就没有任何请求，可以下线了。&lt;/p&gt;

&lt;h3 id=&quot;throttling-pattern&quot;&gt;Throttling Pattern&lt;/h3&gt;

&lt;p&gt;系统压力可能会出现突然的变化，Throttling Pattern 就是通过一定的限制策略，让整个系统的资源消耗保持在安全范围内。&lt;/p&gt;

&lt;p&gt;限制策略包括：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;解决部分请求，比如当一个用户每秒请求数超过每个阈值之后，就不再提供服务；&lt;/li&gt;
  &lt;li&gt;服务降级，次要的服务把资源让给重要的服务使用&lt;/li&gt;
  &lt;li&gt;通过引入 Queue-Based Load Leveling Pattern 来避免负载高峰&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;valet-key-pattern&quot;&gt;Valet Key Pattern&lt;/h3&gt;

&lt;p&gt;有些服务，比如文件的上传下载，往往是由专业的云服务来提供。
Application 只负责管理控制这些资源，而不负责资源本身的处理。
Valet Key 模式，就是指当 Client 请求对一个资源进行操作时，返回给 Client 一个 token，叫做 valet token，Client 拿着这个 token 去请求其他服务。
资源服务通过 Token 可以知道这个 Client 所拥有的权限，以及这些权限的有效期。&lt;/p&gt;</content><summary type="html">写于 2016-12-21 。

Cloud Design Patterns 学习笔记

微软发布了 “Cloud Design Patterns: Prescriptive Architecture Guidance for Cloud Applications “。
书中，针对云应用总结出了多种设计模式和 Guidance 。本文简要记录一下这些 pattern 和 guidance 的思想。

Patterns

Ambassador Pattern

对于遗留服务，它们可能缺少一些我们需要的功能，但我们又离不开它们所提供的的服务。同时这些遗留服务往往都不方便进行改造。
这时候就可以使用 Ambassador Patter，在客户端和服务端之间加一个“代理”，把原来的服务包装起来，提供我们需要的额外功能，比如重试、断路、监控、安全等等。

当然，加一个“代理”会代理更多的成本，有时候提供一个客户端的类库会是更好的方式。

Anti-Corruption Layer Pattern

这个模式也是适用于遗留服务。简单地说就是在新服务和遗留服务之间建立一个转换层，所谓的 Anti-Corruption Layer。通过这一层保证新服务设计的干净，同时又能继续使用遗留服务，知道遗留服务都改造完成。

Backends for Frontends Pattern

即为每一种前端，建立专门的后端服务，这些后端服务又依赖同一套基础服务。
好处是可以针对某种前端方便灵活地提供一些专有功能，而无需考虑其他前端的情况。
代价显然是架构更复杂、模块更多、成本更大。

Bulkhead Pattern

Bulkhead 就是船舱里面的隔板。这些隔板把船舱分隔成很多段，当其中一个段损坏时，海水只会灌进这一个段，而其他段仍然保持完好，船也不会因此沉没。

这个模式就是把服务分成多个组，组与组之间互相隔离，一个组中的失败不会导致整体的失败。比如同一个服务部署多个集群，集群之间互相隔离，每个集群提供给特定的客户使用。

客户端也可以把资源分组，比如为每个依赖的服务分配一个连接池，这样当其中一个服务不响应时，只会耗尽分配给那个服务的连接池，而不会导致整个客户端的连接耗尽。

另外，讲服务分组，还可以为每个组设置优先级，优先保证重要的业务。

Cache-aside Pattern

如果一个 cache 服务没有提供 read-through 和 write-through/write-behind 的功能，比如存粹的缓存服务如
redis 或 memcached 等。可以通过 cache-aside pattern 来模拟 read-through 和
write-through/write-behind 的功能。

大概的过程是：

  APP 查看 cache 中是否有需要的数据，有的话直接拿到；
  如果没有，就从数据存储服务中拿到这个数据；
  在主动的往 cache 中存入这份数据。


Circuit Breaker Pattern

Circuite Breaker 就是断路器，该设计模式用来避免不必要的重试，从而避免雪崩效应。

断路器有3种状态：


  Closed：表示断路器是接通的，即认为后端的服务都是正常的，此时请求将会被正常地提交到服务。当短时间内针对某个服务或资源的失败调用过多时，即当短期内有超过阈值的失败出现时，状态变为 Open；
  Open：表示断路器是断开的，即认为后端的服务出现问题了，此时请求不会提交到服务，而是直接返回失败。进入该状态时，一般会设置一个定时器，定时器到期时把断路器置为 Half-Open 状态；
  Half-Open：表示一种中间状态，断路器不确定后端的服务是否正常，此时会允许部分请求提交到后端，如果这些请求成功了，那就把状态设置为 Closed，否则就回到 Open 状态。


代码实现上，可以创建一个 Circuit Breaker ，把对服务请求相关的逻辑包裹起来。如果是被断路器阻止了，则返回一种特殊的异常，做特殊的处理。

一般还需要一个手工开关，可以把断路器强制设置为某种状态。

在 Half-Open 状态时，除了被动地检查成功和失败数，还可以通过主动的健康检查，来决定下一步的状态。

Command and Query Responsibility Segregation (CQRS) Pattern

即所谓的“命令与查询职责分离”。日常经常说的“读写分离”，其实也算是 CQRS。

CQRS 的核心内容是针对命令（写）和查询（读），使用不同的数据模型，最终数据也存储在不同的存储服务上。

CQRS 和 Event Sourcing 模式经常结合在一起使用。
写模型就是把数据转换为 Event 存入 Event Store。
读模型就是从 Event 中读取 Event stream，转换为需要的业务结构。
这两个模式结合的缺点也很明显：读和写的延迟、额外的复杂性和处理 Event 需要的额外资源。

Compensating Transaction Pattern

补偿事务模式。

一个事务，可能包含一系列的步骤，每个步骤需要调用不同的服务完成。
通过这一系列的步骤，整体上实现最终一致性（eventually consistent）。

所谓的 Compensating Transaction Pattern 就是指，当其中的某一步失败时（经过了一些重试后），
系统自动进行一些列的补偿步骤，比如把之前已经成功的那些步骤回滚掉，实现最终一致性。
这些补偿步骤自己也是有可能会失败的，实现过程中会有一些重试，所以补偿步骤需要是幂等的。

补偿步骤不一定要正好是事务步骤的逆序，而是应该根据具体业务具体实现。

Competing Consumers Pattern

这个模式很简单，其实就是引入一个消息队列。Consumers 从队列中获取任务执行。

Compute Resource Consolidation Pattern

业务逻辑经常包含多个任务，一般情况下，这些任务会部署在独立的计算单元中（虚拟机、容器等）。
这个模式就是把一些任务打包在一起，放在同一个计算单元中运行。
带来的好处就是能够提升资源利用率，降低成本。

但是把任务放到一起，同时也可能带来新的问题，最直接的就是可能增加了复杂度。
原来解耦的任务现在放到了一起，任务之间互相影响，对于容错、安全有更高的要求，架构也变得复杂了。

所以把什么样的任务放在一起，需要仔细选择。一般适用于那些对资源要求不高的，大部分时间都在等待的任务。

Event Sourcing Pattern

一般情况下，我们会存储数据的最新状态。
Event Sourcing 模式利用 Log 的思想，把对数据的所有操作，当做一个个的 Event 存储起来。
通过订阅并且回放这些 Event，我们可以知道数据在在任何时刻的状态。

Event Stream 的量可能会比较大，这时可以考虑在合适的间隔（比如每多少个 Event）时创建 snapshot。

Event 的发布，很可能是“至少一次（at least once”的策略，所以订阅方需要保证 Event 的消费处理时幂等的。

External Configuration Store Pattern

多个 App 之间，一个 App 的多个实例之间往往需要共享配置。
这个模式就是指把配置存到一个外部的专门服务中。该服务提供接口，实现对配置的读和写。
配置服务的实现上，需要考虑很多细节问题，比如权限控制、配置的多版本、配置的数据类型等等。

Federated Identity Pattern

联合身份模式，指 App 把身份认证教给专门的 ID Provider 来进行。优点是简化了 App 的开发，提升了用户体验。

常用的认证方式是“claims-based access control”：

  App/Service 信任 ID Provider（IdP)；
  Client 与 IdP 练习，进行身份认证；
  如果认证通过，IdP 会向 Security Token Service(STS) 返回一个 token，STS 通过该 token 能得到用户的信息（IdP 和 STS 往往是同一个服务）和用户想要的到的权限；
  STS 根据预先设定的规则，对 token 进行转换，添加一些必要的信息，生成一个新的 token，然后返回给 Client；
  Client 使用这个 token 来请求 App/Service；


Gatekeeper Pattern

看门人模式，就是在 App/Service 之前专门增加一个 Gatekeeper 服务，该服务做请求的合法性校验、对请求进行一些清洗（sanitizes requests），然后在 Client 和 App/Services 之间传递数据。

该模式的目的在于增加一层安全性保障。

Gateway Aggregation Pattern

有时候，Client 依赖多个 service，Client 需要请求这些 service 然后合并成为一个结果。
当 Client 与 Service 之间网络不够好时，这会引入严重的性能问题。

Gateway Aggration Pattern 是指在 Client 和 Services 之间引入一个 Gateway，Client 发送一个请求给 Gateway，Gateway 再去请求依赖的所有服务，把这些服务的返回聚合成为一个结果，最后返回给 Client。

Gateway Offloading Pattern

这个模式就是把一些 Service 之间共享的特性，集中到一个新的 Gateway 层进行。
这个特性尤其适用于证书管理、鉴权、SSL termination、监控、协议转换、流量控制等等。

Gateway Routing Pattern

就是最常见的的 Gateway 路由模式，service 不直接暴露给 client，而是统一经由 Gateway 进行路由。

Health Endpoint Monitoring Pattern

这是非常有用的一个模式，Service 对外暴露一个接口，可以查询当前 Service 的健康状况。

要点：

  返回信息的多少、实现难度以及对性能的影响，这三个方面需要有合适的的折中；
  可以考虑暴露多个健康检查接口，分别检查不同重要性的健康情况；
  健康检查的结果可以适当缓存，以减少对性能的影响；
  健康检查接口需要考虑安全性；


Index Table Pattern

这是最常用的设计模式之一。就是为需要查询的数据生成一个索引表。

Leader Election Pattern

就是常用的选主模式。大量的分布式系统都用了该模式，并且可以基于 ZooKeeper，etcd，Consul 等开源软件快速地实现 Leader Election。

Materialized View Pattern

当做数据的存储是，基于不同的存储服务，开发者考虑的往往是“写友好”，而不是“读友好”。
这就导致一些查询的请求，可能需要从存储服务读很多次，才能合并出需要的结果。

该模式的思路，就是主动地生成一些方便读取查询的结果（Materialized View）。这些结果永远不会被直接更新，可以看做是一种特殊的缓存。这些缓存可能存储在完全不同的存储服务上。

需要考虑的点：

  什么时候去更新这些 Materialized View，一帮情况下，可以使用一个任务，或通过某种触发来生成 View。
  考虑数据一致性，这是所有缓存都需要考虑的点。
  考虑为 Materialized View 创建索引表，进一步优化查询性能。


Pipes and Filters Pattern

就是把一个任务分解成一系列的小任务（Filter），然后用管道（Pipe）串联起来，数据在管道中流通。
好处是：

  可以根据每一个 Filter 自身的情况为其分配资源；
  利于扩展改造；


由于每一个 Filter 实例可能会失败，这会导致同一份数据在 Filter 的两个实例上被执行两次，这就：

  Filter 需要是幂等的。
  Pipeline 需要能够检查并且去除重复消息。


该模式可以和补偿事务模式（Compensating Transaction Pattern）一起使用，来实现分布式事务。
因为一个分布式事务可以拆分成为多 Filter，每个 Filter 自身再实现补偿事务模式。

Priority Queue Pattern

对于需要区分优先级的任务的处理，可以通过引入一个优先级队列来实现。

这种模式还有几个变种。

第一个变种是使用多个队列，每个优先级对应一个队列。有一个 Customer Pool，里面的 Customer 总是先试图从高优先级的队列中获取任务，没有的话在尝试下一优先级的队列。

第二个变种是每个优先级对应一个队列，同时还对应一个 Customer Pool，根据优先级的大小确定 Pool 的大小。

第三个变种是动态地改变优先级队列中元素的优先级，随着一个元素在队列中待的时间增加，它的优先级也会逐渐增加。

多队列的方式，有利于系统性能和可扩展性的最大化。

Queue-Based Load Leveling Pattern

基于队列的负载均化模式。
就是在 Service 之前引入一个队列，作为任务的缓冲区。这样可以避免突如其来的负载高峰。
Service 根据自己的能力，按照一定的速率从队列中获取任务执行。

Retry Pattern

就是考虑失败的情况并按照一定策略重试。
关键是根据业务情况，制定合适的重试策略。
可以联合断路器模式（Circuit Breaker pattern）一起使用。

Scheduler Agent Supervisor Pattern

这个模式比较复杂，但很有用。

在分布式的环境中，一个任务，经常会由一系列的步骤组成。
每一个步骤又可能依赖于某个远程服务或远程资源。
这些步骤按照一定的次序执行，只有当所有的步骤都成功时，这个任务才算作成功。

Scheduler Agent Supervisor 模式包含了三种逻辑上的角色：

  Scheduler 的职责是保证任务的各个步骤按照业务需要的正确顺序执行。 Scheduler 需要维护每个步骤的状态信息，包括步骤的过期时间。这些信息存放在持久型数据存储服务中，叫做 state store。如果一个步骤需要调用远程服务，则把相应的信息发送给对应的 Agent。
  Agent 负责代理一个远程服务或远程资源，收到一个消息/请求后，它会根据消息的内容，调用自己代理的远程服务，然后把结果返回给 Scheduler。 Agent需要自己实现重试等机制。每一个远程服务都
  Supervisor 周期性地运行，负责监控由 Scheduler 执行的所有步骤是否在规定的时间内正确完成。


Scheduler，Agent 和 Supervisor 都可以以多实例运行。不过 Supervisor 的多实例之间需要互相同步状态，或者通过 Leader Election 模式选主运行。

这个设计模式的工作方式如下：

  Application 需要运行一个任务时，就向 Scheduler 提交一个请求。
  Scheduler 收到请求后，在 state store 中初始化该任务以及它所有步骤的状态，然后根据业务逻辑顺序来执行步骤。这些步骤必须是幂等的。
  如果一个步骤依赖远程服务，Scheduler 就像对应的 Agent 发送一个消息。
  Agent 收到消息后，根据其内容，调用远程服务，同时还会根据消息中的过期时间，决定是否需要终止执行。如果一切正常，Agent 会向 Scheduler 发送一个运行成功的消息。如果 Agent 没在过期时间前完成工作，则不会向 Scheduler 发送任何消息。
  Supervisor 会定期检查 state store 中的所有状态，看看有哪些步骤超时了或失败了，然后尝试恢复它们。这可以通过更新步骤的过期时间，然后通知 Scheduler 实现。也可以通过 Scheduler 主动轮询 state store 实现。如果一个步骤一直失败，Supervisor 还需要知道什么时候不应该再尝试，或者进一步实现更复杂的策略。Supervisor 最本质的责任，就是当一个步骤失败是，决定是重试该步骤，还是让整个任务失败掉。
  Scheduler 本身也会异常，所以当一个 Scheduler Fail 时，新的或其他的 Scheduler 需要能够恢复那些执行了一半的任务。


Scheduler Agent Supervisor 设计模式最核心的优点，就是在分布式环境下的那些临时的、意外的和不可恢复的异常情况下，整个系统是可“自恢复”的。

Sharding Pattern

就是常用的分片（Sharding）模式。关键是根据业务，选择合适的 Sharding 策略。

Sidecar Pattern

一个 Application 可能需要一系列的附加功能，比如监控、日志、配置等等。
这些服务和 App 本身的关系不大，可以和 App 的每一个实例部署在一起。
就像边三轮摩托车的 Sidecar 一样。
容器天然适合 Sidecar 模式，每个 App 的容器都附带一个 Sidecar 容器。

Static Content Hosting Pattern

就是简单的动静分离模式，把静态内容放在合适的服务上。

Strangler Pattern

老的系统有时需要更新、升级、重构为新系统，这将是一个持续的过程。
Strangler 模式就是把新老系统都接入一个 Strangler 层，Strangler 把改造好了的接口路由给新系统，没有改造好的系统路由给老系统。当整个系统改造完成后，老系统就没有任何请求，可以下线了。

Throttling Pattern

系统压力可能会出现突然的变化，Throttling Pattern 就是通过一定的限制策略，让整个系统的资源消耗保持在安全范围内。

限制策略包括：

  解决部分请求，比如当一个用户每秒请求数超过每个阈值之后，就不再提供服务；
  服务降级，次要的服务把资源让给重要的服务使用
  通过引入 Queue-Based Load Leveling Pattern 来避免负载高峰


Valet Key Pattern

有些服务，比如文件的上传下载，往往是由专业的云服务来提供。
Application 只负责管理控制这些资源，而不负责资源本身的处理。
Valet Key 模式，就是指当 Client 请求对一个资源进行操作时，返回给 Client 一个 token，叫做 valet token，Client 拿着这个 token 去请求其他服务。
资源服务通过 Token 可以知道这个 Client 所拥有的权限，以及这些权限的有效期。</summary></entry><entry><title type="html">读《长恨歌》：一年和一辈子</title><link href="/reading/2017/05/30/%E8%AF%BB-%E9%95%BF%E6%81%A8%E6%AD%8C-%E4%B8%80%E5%B9%B4%E5%92%8C%E4%B8%80%E8%BE%88%E5%AD%90.html" rel="alternate" type="text/html" title="读《长恨歌》：一年和一辈子" /><published>2017-05-30T20:00:00+08:00</published><updated>2017-05-30T20:00:00+08:00</updated><id>/reading/2017/05/30/%E8%AF%BB%E3%80%8A%E9%95%BF%E6%81%A8%E6%AD%8C%E3%80%8B:%E4%B8%80%E5%B9%B4%E5%92%8C%E4%B8%80%E8%BE%88%E5%AD%90</id><content type="html" xml:base="/reading/2017/05/30/%E8%AF%BB-%E9%95%BF%E6%81%A8%E6%AD%8C-%E4%B8%80%E5%B9%B4%E5%92%8C%E4%B8%80%E8%BE%88%E5%AD%90.html">&lt;p&gt;写于 2017-05-30。&lt;/p&gt;

&lt;p&gt;王安忆没有明确地交代王琦瑶的家庭，但她与家里的关系自始至终都很淡。她不喜欢自己的家，不满足自己家能给自己的。从小，就想着要过得好一点，要风光，要体面。这才有了电影厂试镜一段。家里人看她，也是隔着几层心。王琦瑶生孩子时，她妈妈说要是程先生是孩子的爸爸就好了。然而从王琦瑶搬进蒋丽莉家参加选美，到与李主任约会，最后住进了爱丽丝别墅，家里人从来没出现过，他们似乎是用一种希冀的眼光看着王琦瑶，憧憬着风光富贵，面子上虽然吃点亏，但里子里得到的实惠，却是实打实的。&lt;/p&gt;

&lt;p&gt;看小说之前我大概知道会写王琦瑶的一生，当时有个担心，就是怕写文革写得太惨，看不下去。结果文革的十年，也就是王琦瑶35到45岁这一段，王安忆只用了很少很少的笔墨，只写了程先生自杀。想是王安忆觉得写多了左右顾忌，不如不写，直接留白，让读者去想象这究竟是怎么样的十年。直接描写出来，触目惊心，却还是看得见摸得着的。而依靠想象，那关于这段历史的各种见闻，那些个悲惨的事，似乎都会在王琦瑶上发生一遍，让人心疼。&lt;/p&gt;

&lt;p&gt;小说中王琦瑶30岁时说她这一辈子如果按夫妻算的话，只有和李主任算是，虽没名分，却是有情有义的。我不认为，我想这时的王琦瑶还没有想清楚她和李主任的关系。情分自然是有一些的，而这情分是在利益交换的基础上自然积累出来的。李主任得到的是19岁少女的身体，附带着天真、温柔以及与生俱来的女人的聪明，他需要的是一个休息的去处，可以忘却烦恼的逍遥地。王琦瑶得到的，是爱丽丝公寓，是别人羡慕的生活，是那一盒首饰金条，是活在里子的安全感。她对李主任是有真爱的，然而这份爱的建立，却是由于李主任绝对的权利，于她这样的少女，只有尊敬、赞叹和服从的命。如李主任对王琦瑶所说：“我就是你的父母”。&lt;/p&gt;

&lt;p&gt;虽是小说，而我却像个单纯的少年一样，对康明逊充满了怨恨。说是无奈，实际就是懦弱，懦弱到连自己的女人孩子都可以不管不顾。 程先生则是从头到尾的可怜，从一开始就陷入女人的心思中，王琦瑶想要的，他给不了，而自己却痴心着，不知这痴心换来的只有可怜，可怜到让人觉得有点贱。阿二是我最喜欢的一个角色。他喜欢王琦瑶，却没有陷在这份美丽中，于是决定后便走了，不再出现。这么多男人里，虽年纪最小，看起来最柔弱，却有着别人没有的果敢和担当。老克腊这个角色，从一开始就让我觉得不真实。无论在怎么恋旧，王琦瑶保养得再怎么好，终究是30年的差距。也许是我经历有限，但读下来还是有去不掉的跳脱感。&lt;/p&gt;

&lt;p&gt;李主任之后，王琦瑶经常说的一句话就是“我这样的女人”。想想觉得这就是她自己作的。李主任死时她不过20岁，对于大多数人而言这都是人生刚刚开始的时候，然后王琦瑶却觉得自己经历过了。她这一辈子的基础，就是和李主任在一起的一年。甚至她的死，也还是因为那一盒金条。&lt;/p&gt;

&lt;p&gt;从姑娘开始，王琦瑶就不是一个讨人喜欢的女人。但似乎是典型的上海女人，细腻、精致、聪明，同时也精于算计和心眼，什么事情都想占着便宜。虽不招人喜欢，却也让人可怜。她的虚荣心并没有比其他女孩多一分，不过是长得更美。而在时代的变迁下，长得美，能让她在浪潮中冲得更高，也陷得更深。&lt;/p&gt;</content><summary type="html">写于 2017-05-30。

王安忆没有明确地交代王琦瑶的家庭，但她与家里的关系自始至终都很淡。她不喜欢自己的家，不满足自己家能给自己的。从小，就想着要过得好一点，要风光，要体面。这才有了电影厂试镜一段。家里人看她，也是隔着几层心。王琦瑶生孩子时，她妈妈说要是程先生是孩子的爸爸就好了。然而从王琦瑶搬进蒋丽莉家参加选美，到与李主任约会，最后住进了爱丽丝别墅，家里人从来没出现过，他们似乎是用一种希冀的眼光看着王琦瑶，憧憬着风光富贵，面子上虽然吃点亏，但里子里得到的实惠，却是实打实的。

看小说之前我大概知道会写王琦瑶的一生，当时有个担心，就是怕写文革写得太惨，看不下去。结果文革的十年，也就是王琦瑶35到45岁这一段，王安忆只用了很少很少的笔墨，只写了程先生自杀。想是王安忆觉得写多了左右顾忌，不如不写，直接留白，让读者去想象这究竟是怎么样的十年。直接描写出来，触目惊心，却还是看得见摸得着的。而依靠想象，那关于这段历史的各种见闻，那些个悲惨的事，似乎都会在王琦瑶上发生一遍，让人心疼。

小说中王琦瑶30岁时说她这一辈子如果按夫妻算的话，只有和李主任算是，虽没名分，却是有情有义的。我不认为，我想这时的王琦瑶还没有想清楚她和李主任的关系。情分自然是有一些的，而这情分是在利益交换的基础上自然积累出来的。李主任得到的是19岁少女的身体，附带着天真、温柔以及与生俱来的女人的聪明，他需要的是一个休息的去处，可以忘却烦恼的逍遥地。王琦瑶得到的，是爱丽丝公寓，是别人羡慕的生活，是那一盒首饰金条，是活在里子的安全感。她对李主任是有真爱的，然而这份爱的建立，却是由于李主任绝对的权利，于她这样的少女，只有尊敬、赞叹和服从的命。如李主任对王琦瑶所说：“我就是你的父母”。

虽是小说，而我却像个单纯的少年一样，对康明逊充满了怨恨。说是无奈，实际就是懦弱，懦弱到连自己的女人孩子都可以不管不顾。 程先生则是从头到尾的可怜，从一开始就陷入女人的心思中，王琦瑶想要的，他给不了，而自己却痴心着，不知这痴心换来的只有可怜，可怜到让人觉得有点贱。阿二是我最喜欢的一个角色。他喜欢王琦瑶，却没有陷在这份美丽中，于是决定后便走了，不再出现。这么多男人里，虽年纪最小，看起来最柔弱，却有着别人没有的果敢和担当。老克腊这个角色，从一开始就让我觉得不真实。无论在怎么恋旧，王琦瑶保养得再怎么好，终究是30年的差距。也许是我经历有限，但读下来还是有去不掉的跳脱感。

李主任之后，王琦瑶经常说的一句话就是“我这样的女人”。想想觉得这就是她自己作的。李主任死时她不过20岁，对于大多数人而言这都是人生刚刚开始的时候，然后王琦瑶却觉得自己经历过了。她这一辈子的基础，就是和李主任在一起的一年。甚至她的死，也还是因为那一盒金条。

从姑娘开始，王琦瑶就不是一个讨人喜欢的女人。但似乎是典型的上海女人，细腻、精致、聪明，同时也精于算计和心眼，什么事情都想占着便宜。虽不招人喜欢，却也让人可怜。她的虚荣心并没有比其他女孩多一分，不过是长得更美。而在时代的变迁下，长得美，能让她在浪潮中冲得更高，也陷得更深。</summary></entry><entry><title type="html">《刻意练习》读书笔记</title><link href="/reading/2017/05/30/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="《刻意练习》读书笔记" /><published>2017-05-30T15:30:00+08:00</published><updated>2017-05-30T15:30:00+08:00</updated><id>/reading/2017/05/30/%E3%80%8A%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/reading/2017/05/30/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">&lt;p&gt;写于 2017-05-30。&lt;/p&gt;

&lt;p&gt;“刻意练习（deliberate practice）”的概念，我最早在万维钢的《万万没想到》中了解到，核心思想是专注、高强度和快速反馈。这本《刻意练习》，以一整本书的篇幅，仔细介绍了这个概念，包括其背后的科学数据以及实践经验。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;阳志平的推荐序&lt;/h2&gt;

&lt;p&gt;刻意练习的指向和本，质是加强人的“长时记忆”（本书中，叫做“心理表征”），这是区别卓越者和一般人的重要能力。长时记忆的培养点主要是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;赋予意义、精细编码。&lt;/li&gt;
  &lt;li&gt;提取结构或模式。&lt;/li&gt;
  &lt;li&gt;加快速度、增加连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;情境学习&lt;/strong&gt;：成人的最佳学习方式并非独自练习，而是在情境中学习。进入相关情境，找到自己的“学习共同体”，开始时围绕重要成员转，做一些外围的工作，随着技能的增长，进入学习共同体圈子的核心，逐步做更重要的工作，最终成为专家。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;第一章：有目的的练习&lt;/h2&gt;

&lt;p&gt;对于一项能力，当表现达到了某个水平，并且可以做到自动化，那么更多时间的练习并不能带来进步。练习需要有目的。有目的的练习，具有四个特点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;具有定义明确的特定目标，一定要明确地知道目标是否达到。&lt;/li&gt;
  &lt;li&gt;专注。不要有任何干扰。&lt;/li&gt;
  &lt;li&gt;快速反馈，无论什么事情，都需要有一个测量的方法，告诉自己当前状态如何，应该朝着什么方向前进。&lt;/li&gt;
  &lt;li&gt;走出舒适区，当练习变得快乐时，就不在是刻意练习了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;遇到瓶颈时，试着做不同的事情，而非更难的事情。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;第二章：大脑的适应能力&lt;/h2&gt;

&lt;p&gt;大脑就像肌肉，训练能让大脑更强大。只有引起不适，身体才会发生变化，才能到达训练的目的。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;第三章：心理表征&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;心理表征是一种与我们大脑正在思考的某个物体、某个观点、某些信息或者其他任何事物相对应的心理结构，或具体抽象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;心理表征的质量与数量，决定了杰出和普通。&lt;/p&gt;

&lt;p&gt;有一种说法是，把一个东西讲述给别人听，或者写下来，是学习一个东西的最有效方法之一。其实这取决于怎么讲述。一种讲述的方式叫做“知识陈述（knowledge telling）”，就是把大脑中所有的观点一一告诉读者。另一种讲述的方式叫做“知识转换（knowledge transforming）”，就是建立自己的心理表征，在讲述和写作的过程中，改变并增加了一开始所拥有的知识。做到这一步，才能称为掌握了某种知识。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;第四章：黄金标准&lt;/h2&gt;

&lt;p&gt;一项练习，除了要有目的，还需要具备下面这些标准，才能称为刻意练习。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;刻意练习发展的技能，已经拥有一套行之有效的训练方法。&lt;/li&gt;
  &lt;li&gt;刻意练习发生在舒适区外，需要持续不断地尝试那些刚好超出当前能力范围的事物。&lt;/li&gt;
  &lt;li&gt;刻意练习包含定义良好的目标，并且能够看到离目标还有多远。&lt;/li&gt;
  &lt;li&gt;刻意练习是有意而为的，仅仅是遵照指示并不够，需要主动的关注，自己做适当的调整，控制练习。&lt;/li&gt;
  &lt;li&gt;刻意练习需要反馈，以及及时的调整。反馈一开始可能来自导师和教练，但学生必须学会自我监测的方法，这也是建立心理表征的过程。&lt;/li&gt;
  &lt;li&gt;刻意练习的过程是心理表征逐渐形成和改进的过程。&lt;/li&gt;
  &lt;li&gt;刻意练习关注那些过去掌握的技能的某些方面，不断地重新构建和修改，实现基本技能的重新学习。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-5&quot;&gt;第五章：在工作中运用刻意练习原则&lt;/h2&gt;

&lt;p&gt;传统的训练培养，着重的是知识的传授。而刻意练习，关注的是技能的发展。在工作中，培训计划应该致力于改进技能， 而非掌握知识。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;第六章：在生活中运用刻意练习原则&lt;/h2&gt;

&lt;p&gt;在较短时间内投入100%的努力来练习，比起在更长时间内只投入70%的努力来练习，效果更好。&lt;/p&gt;

&lt;p&gt;找到自己的导师，或者该领域的专家，研究他们是如何成为卓越的。&lt;/p&gt;

&lt;p&gt;用“三个F”创建有效的心理表征：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Focus（专注）；&lt;/li&gt;
  &lt;li&gt;Feedback（反馈）；&lt;/li&gt;
  &lt;li&gt;Fixit（纠正）；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-7&quot;&gt;第七章：成为杰出人物的路线图&lt;/h2&gt;

&lt;p&gt;四个阶段：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;产生兴趣。&lt;/li&gt;
  &lt;li&gt;变得认真。&lt;/li&gt;
  &lt;li&gt;全力投入。&lt;/li&gt;
  &lt;li&gt;开拓创新。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-8&quot;&gt;第八章：怎样解释天生才华&lt;/h2&gt;

&lt;p&gt;天赋的差异会在一开始学习某项技能时产生影响，但随着时间的推移，又天赋本身造成的影响会越来越少。真正成就杰出的，还是靠的持续不断的刻意练习。&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;第九章：用刻意练习创造全新的世界&lt;/h2&gt;

&lt;p&gt;这个世界是什么样子，取决于我们怎么看待这个世界，这又取决于我们都拥有哪些心理表征。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;你在思考某件事情的时候，不会创建心理表征；只有通过去做某件事情，失败了之后调整方法，接着再去做，如此循环往复，才能创建心理表征。&lt;/p&gt;
&lt;/blockquote&gt;</content><summary type="html">写于 2017-05-30。

“刻意练习（deliberate practice）”的概念，我最早在万维钢的《万万没想到》中了解到，核心思想是专注、高强度和快速反馈。这本《刻意练习》，以一整本书的篇幅，仔细介绍了这个概念，包括其背后的科学数据以及实践经验。

阳志平的推荐序

刻意练习的指向和本，质是加强人的“长时记忆”（本书中，叫做“心理表征”），这是区别卓越者和一般人的重要能力。长时记忆的培养点主要是：

  赋予意义、精细编码。
  提取结构或模式。
  加快速度、增加连接。


情境学习：成人的最佳学习方式并非独自练习，而是在情境中学习。进入相关情境，找到自己的“学习共同体”，开始时围绕重要成员转，做一些外围的工作，随着技能的增长，进入学习共同体圈子的核心，逐步做更重要的工作，最终成为专家。

第一章：有目的的练习

对于一项能力，当表现达到了某个水平，并且可以做到自动化，那么更多时间的练习并不能带来进步。练习需要有目的。有目的的练习，具有四个特点：

  具有定义明确的特定目标，一定要明确地知道目标是否达到。
  专注。不要有任何干扰。
  快速反馈，无论什么事情，都需要有一个测量的方法，告诉自己当前状态如何，应该朝着什么方向前进。
  走出舒适区，当练习变得快乐时，就不在是刻意练习了。


遇到瓶颈时，试着做不同的事情，而非更难的事情。

第二章：大脑的适应能力

大脑就像肌肉，训练能让大脑更强大。只有引起不适，身体才会发生变化，才能到达训练的目的。

第三章：心理表征


  心理表征是一种与我们大脑正在思考的某个物体、某个观点、某些信息或者其他任何事物相对应的心理结构，或具体抽象。


心理表征的质量与数量，决定了杰出和普通。

有一种说法是，把一个东西讲述给别人听，或者写下来，是学习一个东西的最有效方法之一。其实这取决于怎么讲述。一种讲述的方式叫做“知识陈述（knowledge telling）”，就是把大脑中所有的观点一一告诉读者。另一种讲述的方式叫做“知识转换（knowledge transforming）”，就是建立自己的心理表征，在讲述和写作的过程中，改变并增加了一开始所拥有的知识。做到这一步，才能称为掌握了某种知识。

第四章：黄金标准

一项练习，除了要有目的，还需要具备下面这些标准，才能称为刻意练习。

  刻意练习发展的技能，已经拥有一套行之有效的训练方法。
  刻意练习发生在舒适区外，需要持续不断地尝试那些刚好超出当前能力范围的事物。
  刻意练习包含定义良好的目标，并且能够看到离目标还有多远。
  刻意练习是有意而为的，仅仅是遵照指示并不够，需要主动的关注，自己做适当的调整，控制练习。
  刻意练习需要反馈，以及及时的调整。反馈一开始可能来自导师和教练，但学生必须学会自我监测的方法，这也是建立心理表征的过程。
  刻意练习的过程是心理表征逐渐形成和改进的过程。
  刻意练习关注那些过去掌握的技能的某些方面，不断地重新构建和修改，实现基本技能的重新学习。


第五章：在工作中运用刻意练习原则

传统的训练培养，着重的是知识的传授。而刻意练习，关注的是技能的发展。在工作中，培训计划应该致力于改进技能， 而非掌握知识。

第六章：在生活中运用刻意练习原则

在较短时间内投入100%的努力来练习，比起在更长时间内只投入70%的努力来练习，效果更好。

找到自己的导师，或者该领域的专家，研究他们是如何成为卓越的。

用“三个F”创建有效的心理表征：

  Focus（专注）；
  Feedback（反馈）；
  Fixit（纠正）；


第七章：成为杰出人物的路线图

四个阶段：

  产生兴趣。
  变得认真。
  全力投入。
  开拓创新。


第八章：怎样解释天生才华

天赋的差异会在一开始学习某项技能时产生影响，但随着时间的推移，又天赋本身造成的影响会越来越少。真正成就杰出的，还是靠的持续不断的刻意练习。

第九章：用刻意练习创造全新的世界

这个世界是什么样子，取决于我们怎么看待这个世界，这又取决于我们都拥有哪些心理表征。


  你在思考某件事情的时候，不会创建心理表征；只有通过去做某件事情，失败了之后调整方法，接着再去做，如此循环往复，才能创建心理表征。</summary></entry><entry><title type="html">《学会提问》读书笔记</title><link href="/reading/2017/03/11/%E5%AD%A6%E4%BC%9A%E6%8F%90%E9%97%AE-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="《学会提问》读书笔记" /><published>2017-03-11T10:00:00+08:00</published><updated>2017-03-11T10:00:00+08:00</updated><id>/reading/2017/03/11/%E3%80%8A%E5%AD%A6%E4%BC%9A%E6%8F%90%E9%97%AE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/reading/2017/03/11/%E5%AD%A6%E4%BC%9A%E6%8F%90%E9%97%AE-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">&lt;p&gt;写于 2017-03-11。&lt;/p&gt;

&lt;p&gt;从小就听到一句话：要用批判性的眼光来读书，小时候以为就是要努力挑错。&lt;/p&gt;

&lt;p&gt;什么是批判性思维？《学会提问》这本书中，作者给出了“淘金式思维”的比喻：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;采用淘金式思维的读者常常质疑作者为何要提出各种各样的主张。他在书本的页边写批注，提醒自己注意作者推理和论述中存在的问题。他无时无刻不在和自己的阅读材料互动，目的是批判性地评价所读的材料，在客观评价的基础上得出自己的结论。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;批判性思维的本质，就是面对信息，我们应该怎么做，才能让自己掌握信息的核心，扩充自己的知识体系，让我们更具备主动权，拥有独立思考能力，保持清醒和理性。而不是被无知和谬误充斥在大脑中，被牵着鼻子走，陷入混沌与迷茫。&lt;/p&gt;

&lt;p&gt;作者认为进行批判性思维最重要的方法是互动，也就是不断地提问。这也是这本书书名的由来。&lt;/p&gt;

&lt;p&gt;批判性思维要求人既是对外的，也是对内的。很多时候我们会下意识地选择那些与既有观点一致的信息，而不是全面地评估所有论点论据。心智的发展、知识体系的生长，需要不断地修正。“我唯一知道的就是我一无所知”，保持谦卑并且开放的心态，允许甚至渴望自己的认知被外界和自己不断地挑战、修正乃至颠覆。因为我们理性地知道，这只会让自己更强大、更具人性。&lt;/p&gt;

&lt;p&gt;我认为，批判性思维能让人们的价值观差别逐渐减小，然而它并不能解决根本价值观差异导致的认知差异。事实上批判性思维这个方法本身，就是构建在理性、科学和逻辑的价值观之上。人生的意义是什么，这个宇宙到底多大程度上是可以理解的，个人与整体是什么关系，当下与过去、未来是怎样叠加纠缠在一起的，这些“终极问题”的解答，只能通过信仰。科学、逻辑和理性本身，也是一种信仰。&lt;/p&gt;

&lt;p&gt;掌握了“批判性思维”的“道”，明确了“不断提问”的“法”，书中的大部分内容，就简单地是“术”了。&lt;/p&gt;

&lt;p&gt;读完这本书后我对批判性思维具体方法的理解，基本分为三部分：&lt;/p&gt;

&lt;p&gt;第一，提炼论点、论据和推理方法。无论什么样的信息，在进行下一步之前，都需要找到它要表达的到底是什么，否则一切都会失去基础。&lt;/p&gt;

&lt;p&gt;第二，考察推理过程的合理性。这是最容易出谬误的一步，作者在书中提到了一些常见的谬误，很有必要列出来：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;偷换概念谬误。&lt;/li&gt;
  &lt;li&gt;诉诸公众谬误。&lt;/li&gt;
  &lt;li&gt;诉诸可疑权威谬误。&lt;/li&gt;
  &lt;li&gt;诉诸感情谬误。&lt;/li&gt;
  &lt;li&gt;稻草人谬误。指歪曲对方观点，使其容易受到攻击，而事实上我们攻击的观点根本就不存在。&lt;/li&gt;
  &lt;li&gt;虚假的两难选择谬误。&lt;/li&gt;
  &lt;li&gt;光环效应缪我。指使用模糊、引发人们强烈感情认同哦美德词汇，使我们倾向于统一某件事而不去细致检查其理由。&lt;/li&gt;
  &lt;li&gt;转移话题谬误。&lt;/li&gt;
  &lt;li&gt;循环论证谬误。&lt;/li&gt;
  &lt;li&gt;以偏概全谬误。&lt;/li&gt;
  &lt;li&gt;强求确定性谬误。指认为一个研究结论如果不是百分之百确定的话就应该被抛弃。&lt;/li&gt;
  &lt;li&gt;错误类比谬误。&lt;/li&gt;
  &lt;li&gt;过度简化原因谬误。&lt;/li&gt;
  &lt;li&gt;事后归因谬误。指仅仅因为事件乙时间上在事件甲之后发生，就认为乙是由甲所造成的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第三，得出合理的结论，扩展、修正自己的认知体系。对一个信息进行批判性地分析后，必然会有所收获。如果这是个有价值的信息，那就可以扩充进自己的认知体系中，同时带来自省和修正。如果这个信息是荒谬的或没有有效信息的，那我们也知道世界上还有这样一种观点存在，有这样一些人存在，同时也让我们以后能够更高效地选择过滤信息。&lt;/p&gt;</content><summary type="html">写于 2017-03-11。

从小就听到一句话：要用批判性的眼光来读书，小时候以为就是要努力挑错。

什么是批判性思维？《学会提问》这本书中，作者给出了“淘金式思维”的比喻：


  采用淘金式思维的读者常常质疑作者为何要提出各种各样的主张。他在书本的页边写批注，提醒自己注意作者推理和论述中存在的问题。他无时无刻不在和自己的阅读材料互动，目的是批判性地评价所读的材料，在客观评价的基础上得出自己的结论。


批判性思维的本质，就是面对信息，我们应该怎么做，才能让自己掌握信息的核心，扩充自己的知识体系，让我们更具备主动权，拥有独立思考能力，保持清醒和理性。而不是被无知和谬误充斥在大脑中，被牵着鼻子走，陷入混沌与迷茫。

作者认为进行批判性思维最重要的方法是互动，也就是不断地提问。这也是这本书书名的由来。

批判性思维要求人既是对外的，也是对内的。很多时候我们会下意识地选择那些与既有观点一致的信息，而不是全面地评估所有论点论据。心智的发展、知识体系的生长，需要不断地修正。“我唯一知道的就是我一无所知”，保持谦卑并且开放的心态，允许甚至渴望自己的认知被外界和自己不断地挑战、修正乃至颠覆。因为我们理性地知道，这只会让自己更强大、更具人性。

我认为，批判性思维能让人们的价值观差别逐渐减小，然而它并不能解决根本价值观差异导致的认知差异。事实上批判性思维这个方法本身，就是构建在理性、科学和逻辑的价值观之上。人生的意义是什么，这个宇宙到底多大程度上是可以理解的，个人与整体是什么关系，当下与过去、未来是怎样叠加纠缠在一起的，这些“终极问题”的解答，只能通过信仰。科学、逻辑和理性本身，也是一种信仰。

掌握了“批判性思维”的“道”，明确了“不断提问”的“法”，书中的大部分内容，就简单地是“术”了。

读完这本书后我对批判性思维具体方法的理解，基本分为三部分：

第一，提炼论点、论据和推理方法。无论什么样的信息，在进行下一步之前，都需要找到它要表达的到底是什么，否则一切都会失去基础。

第二，考察推理过程的合理性。这是最容易出谬误的一步，作者在书中提到了一些常见的谬误，很有必要列出来：

  偷换概念谬误。
  诉诸公众谬误。
  诉诸可疑权威谬误。
  诉诸感情谬误。
  稻草人谬误。指歪曲对方观点，使其容易受到攻击，而事实上我们攻击的观点根本就不存在。
  虚假的两难选择谬误。
  光环效应缪我。指使用模糊、引发人们强烈感情认同哦美德词汇，使我们倾向于统一某件事而不去细致检查其理由。
  转移话题谬误。
  循环论证谬误。
  以偏概全谬误。
  强求确定性谬误。指认为一个研究结论如果不是百分之百确定的话就应该被抛弃。
  错误类比谬误。
  过度简化原因谬误。
  事后归因谬误。指仅仅因为事件乙时间上在事件甲之后发生，就认为乙是由甲所造成的。


第三，得出合理的结论，扩展、修正自己的认知体系。对一个信息进行批判性地分析后，必然会有所收获。如果这是个有价值的信息，那就可以扩充进自己的认知体系中，同时带来自省和修正。如果这个信息是荒谬的或没有有效信息的，那我们也知道世界上还有这样一种观点存在，有这样一些人存在，同时也让我们以后能够更高效地选择过滤信息。</summary></entry><entry><title type="html">《精进》读书笔记</title><link href="/reading/2017/02/19/%E7%B2%BE%E8%BF%9B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="《精进》读书笔记" /><published>2017-02-19T16:40:00+08:00</published><updated>2017-02-19T16:40:00+08:00</updated><id>/reading/2017/02/19/%E3%80%8A%E7%B2%BE%E8%BF%9B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/reading/2017/02/19/%E7%B2%BE%E8%BF%9B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">&lt;p&gt;写于2017-02-19。&lt;/p&gt;

&lt;p&gt;作者采铜心理学专业出身，在书中用大量的事例，从心理学的角度，阐述了他对时间和学习的看法。虽然都是些零零碎碎的知识，不成体系，但也能启发一些思考，值得一读。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;郑重地对待时间&lt;/h3&gt;

&lt;p&gt;作者认为应该以“郑重”的态度对待时间，这个观点来自梁漱溟。所谓郑重是指“不敷衍、不迟疑、不摇摆，认真地聚焦于当下的事情，自觉而专注地投入”。应该建立一种平衡的时间观：不过分沉浸在过去，又以过去为依托，不盲目向往着未来，又相信时间和积累。这是一种“延伸的当下感”（extended now，来自于瑞典心理学家 Lindvall）。关键在于平衡，在于取舍。一方面为了更好的未来努力，一方面又能够享受当下的美好。很喜欢书中引用的朱光潜的话：“做学问，做事业，在人生中都只能算是第二桩事。人生的第一桩事是生活。我所谓‘生活’是‘享受’，是‘领略’，是‘培养生机’。假若为学问为事业而忘却生活，那种学问和事业在人生中便失去其真正意义与价值。”&lt;/p&gt;

&lt;p&gt;秉持郑重对待时间的态度，作者给出了一些建议：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;工作可以“快”起来，而生活应该“慢”下来；&lt;/li&gt;
  &lt;li&gt;删减不必要的事情，选择那些“半衰期”长的事情；&lt;/li&gt;
  &lt;li&gt;主动式放松（比如做感兴趣的事）比被动式休闲（比如看电视）更有意义；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;人生的格局&lt;/h3&gt;

&lt;p&gt;作者认为，一件事情值不值得做，应该看它是否与我们的最高目标一致。要用于说不，因为绝大部分事情与最高目标没有什么关联。而目标的确定，取决于一个人的“格局”。作者提出了四个层次的格局：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;零度格局：盲众。没有独立思考能力，只是追寻潮流，生活在别人的观点中。&lt;/li&gt;
  &lt;li&gt;一度格局：逐利者。寻求自身利益的最大化，注重与逐利相关的各种知识技能。&lt;/li&gt;
  &lt;li&gt;二度格局：理念人。为理念而生，准求和捍卫他们心目中的真理。&lt;/li&gt;
  &lt;li&gt;三度格局：至善之人。认为自己对芸芸众生负有责任，所做的事情时为了增进人类的福祉。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;书中引用了史怀哲的一句话，来表达三度格局：“人不能只为他自己而活。我们必须认知所有的生命都是珍贵的，而我们和所有的生命是结合在一起的。这种认知指引了我们心灵和宇宙的关系。”&lt;/p&gt;

&lt;p&gt;史怀哲这句话让我想到了电影《云图》，从子宫到坟墓，无论在什么时间，人与人之间都连接在一起，构成一幅跨越时空的云图。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;即刻行动，及时反思&lt;/h3&gt;

&lt;p&gt;心理学上有个著名的“象与骑象人”的隐喻，说的是大脑就像一头大象，我们意识到的只是很少一部分，很大部分工作是隐性的。作者引用了唐纳德·舍恩的观点：“‘三思而后行’不一定正确，很多时候甚至可以是‘行动先于思考‘的，因为‘人们的机智行动是高度技巧及复杂推理而形成的，而其中绝大多数又是隐性的’，因此在行动之后反思，可能会反过来发展我们的认识”。即刻行动和及时反思相辅相成，没有反思的行动是盲目的。&lt;/p&gt;

&lt;p&gt;充分利用大脑隐性的部分，作者也给出了一些技巧。比如关掉大脑中评价的声音，适当引入随机，借助纸和笔扩充自己大脑的思维空间等等。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;边做边学&lt;/h3&gt;

&lt;p&gt;作者认为求知分为三个层级：信息、知识和技能，最有效的学习方法，是把知识当成是一项技能来学习。这一点自己也很认同，比如学习一门新的编程语言，最有效的就是用这门语言做一个小工具。比如学习一门新科学，最有效的方法就是针对一个问题做一个调研，写一篇论文。让自己有所输出，写文字、给被人讲解等，也是一种做的方法。大脑很“懒”，你以为自己明白了，实际上往往并不明白。输出的过程，就是让大脑真正去思考、归纳、总结、创建知识关联的过程。&lt;/p&gt;

&lt;p&gt;我认为，一个人知识体系的建立，就像在纸上画一棵树，主要有两种方法。一是系统地对某项知识进行学习，就是先画树干树枝，再逐渐填补树叶。二是零散知识点的学习，就像是先一点一点地画树叶，可能这里一片那里一片，互补相连，也看不出是一棵树来，之后某个时间正好画树干树枝时，会发现这一片的树叶早就画好了，突然之间这些树叶就有了联系，形成了体系。两种方式无所谓孰优孰劣，大段固定的时间适合画树枝，碎片化时间适合画树叶。&lt;/p&gt;

&lt;p&gt;作者也有类似的观点：大部分的时间进行既定领域的深入学习，即主业，但一定要有小部分的时间广泛涉猎，进行各种领域的探索和尝试，不期望从中得到明确的利益，但能让我们以新的维度看待事物，能让我们的生命更加精彩，能让我们捕捉到未曾预料的机会。&lt;/p&gt;</content><summary type="html">写于2017-02-19。

作者采铜心理学专业出身，在书中用大量的事例，从心理学的角度，阐述了他对时间和学习的看法。虽然都是些零零碎碎的知识，不成体系，但也能启发一些思考，值得一读。

郑重地对待时间

作者认为应该以“郑重”的态度对待时间，这个观点来自梁漱溟。所谓郑重是指“不敷衍、不迟疑、不摇摆，认真地聚焦于当下的事情，自觉而专注地投入”。应该建立一种平衡的时间观：不过分沉浸在过去，又以过去为依托，不盲目向往着未来，又相信时间和积累。这是一种“延伸的当下感”（extended now，来自于瑞典心理学家 Lindvall）。关键在于平衡，在于取舍。一方面为了更好的未来努力，一方面又能够享受当下的美好。很喜欢书中引用的朱光潜的话：“做学问，做事业，在人生中都只能算是第二桩事。人生的第一桩事是生活。我所谓‘生活’是‘享受’，是‘领略’，是‘培养生机’。假若为学问为事业而忘却生活，那种学问和事业在人生中便失去其真正意义与价值。”

秉持郑重对待时间的态度，作者给出了一些建议：

  工作可以“快”起来，而生活应该“慢”下来；
  删减不必要的事情，选择那些“半衰期”长的事情；
  主动式放松（比如做感兴趣的事）比被动式休闲（比如看电视）更有意义；


人生的格局

作者认为，一件事情值不值得做，应该看它是否与我们的最高目标一致。要用于说不，因为绝大部分事情与最高目标没有什么关联。而目标的确定，取决于一个人的“格局”。作者提出了四个层次的格局：

  零度格局：盲众。没有独立思考能力，只是追寻潮流，生活在别人的观点中。
  一度格局：逐利者。寻求自身利益的最大化，注重与逐利相关的各种知识技能。
  二度格局：理念人。为理念而生，准求和捍卫他们心目中的真理。
  三度格局：至善之人。认为自己对芸芸众生负有责任，所做的事情时为了增进人类的福祉。


书中引用了史怀哲的一句话，来表达三度格局：“人不能只为他自己而活。我们必须认知所有的生命都是珍贵的，而我们和所有的生命是结合在一起的。这种认知指引了我们心灵和宇宙的关系。”

史怀哲这句话让我想到了电影《云图》，从子宫到坟墓，无论在什么时间，人与人之间都连接在一起，构成一幅跨越时空的云图。

即刻行动，及时反思

心理学上有个著名的“象与骑象人”的隐喻，说的是大脑就像一头大象，我们意识到的只是很少一部分，很大部分工作是隐性的。作者引用了唐纳德·舍恩的观点：“‘三思而后行’不一定正确，很多时候甚至可以是‘行动先于思考‘的，因为‘人们的机智行动是高度技巧及复杂推理而形成的，而其中绝大多数又是隐性的’，因此在行动之后反思，可能会反过来发展我们的认识”。即刻行动和及时反思相辅相成，没有反思的行动是盲目的。

充分利用大脑隐性的部分，作者也给出了一些技巧。比如关掉大脑中评价的声音，适当引入随机，借助纸和笔扩充自己大脑的思维空间等等。

边做边学

作者认为求知分为三个层级：信息、知识和技能，最有效的学习方法，是把知识当成是一项技能来学习。这一点自己也很认同，比如学习一门新的编程语言，最有效的就是用这门语言做一个小工具。比如学习一门新科学，最有效的方法就是针对一个问题做一个调研，写一篇论文。让自己有所输出，写文字、给被人讲解等，也是一种做的方法。大脑很“懒”，你以为自己明白了，实际上往往并不明白。输出的过程，就是让大脑真正去思考、归纳、总结、创建知识关联的过程。

我认为，一个人知识体系的建立，就像在纸上画一棵树，主要有两种方法。一是系统地对某项知识进行学习，就是先画树干树枝，再逐渐填补树叶。二是零散知识点的学习，就像是先一点一点地画树叶，可能这里一片那里一片，互补相连，也看不出是一棵树来，之后某个时间正好画树干树枝时，会发现这一片的树叶早就画好了，突然之间这些树叶就有了联系，形成了体系。两种方式无所谓孰优孰劣，大段固定的时间适合画树枝，碎片化时间适合画树叶。

作者也有类似的观点：大部分的时间进行既定领域的深入学习，即主业，但一定要有小部分的时间广泛涉猎，进行各种领域的探索和尝试，不期望从中得到明确的利益，但能让我们以新的维度看待事物，能让我们的生命更加精彩，能让我们捕捉到未曾预料的机会。</summary></entry><entry><title type="html">《极客与团队》读书笔记</title><link href="/reading/2017/02/18/%E6%9E%81%E5%AE%A2%E4%B8%8E%E5%9B%A2%E9%98%9F-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="《极客与团队》读书笔记" /><published>2017-02-18T10:40:00+08:00</published><updated>2017-02-18T10:40:00+08:00</updated><id>/reading/2017/02/18/%E3%80%8A%E6%9E%81%E5%AE%A2%E4%B8%8E%E5%9B%A2%E9%98%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/reading/2017/02/18/%E6%9E%81%E5%AE%A2%E4%B8%8E%E5%9B%A2%E9%98%9F-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">&lt;p&gt;写于 2017-02-18 。&lt;/p&gt;

&lt;p&gt;两位作者 Brian W. Fitzpatrick 和 Ben Collins-Sussman 都有在开源项目（Subversion）和大公司（Google）管理工程团队的经验。&lt;/p&gt;

&lt;p&gt;作者们认为，优秀的工程师文化的核心是 HRT：谦虚（Humility），尊重（Respect）和信任（Trust）。整本书就是对 HRT 的阐释、示例和应用建议。同时还夹杂着创建维护优秀工程师文化的各种经验和技巧。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;主要内容&lt;/h2&gt;

&lt;h4 id=&quot;section-1&quot;&gt;优秀的个人依托于优秀的团队&lt;/h4&gt;

&lt;p&gt;现代社会大部分的工作对于单独个体来说已经太过复杂，要把事情做成功，只能依靠协作。应该正确认识社交的意义：“ 社交……是通过建立起人与人之间的关系来把事情做成功，而且这种关系延续的时间肯定比项目本身更长。”&lt;/p&gt;

&lt;p&gt;团队文化的定义和维护是每个成员的事，而不仅仅是创始人和负责人的事。关于这一点，拉兹洛·博克在《重新定义团队：谷歌如何工作》中也有类似的观点。他认为“任何人都有能力成为一名创始人，也可以成为所在团队的文化创造者”。&lt;/p&gt;

&lt;h4 id=&quot;leader-&quot;&gt;优秀 Leader 的素质&lt;/h4&gt;

&lt;p&gt;Leader 应该关心做什么而非怎么做，相信团队能自己找的解决问题的方法。设置明确的目标，也是让团队齐心协力的有效方法。最好的激励方式，就是项目对每个成员来说都能够成为内部激励。对于工程师来说，只需提供三样东西：自主、精通和目标。&lt;/p&gt;

&lt;p&gt;提问是提供帮助有效形式。Leader 的眼光应该放长。不应只关心这一个问题的解决，而是要帮助成员成长。通过提问的方式一步步引导，让成员依靠自己的力量找到答案，是对他们技术、主人翁意识和责任感的培养。&lt;/p&gt;

&lt;p&gt;允许失败。因为 即使失败了，相比于只尝试那些你知道自己肯定能完成，你所得到的会多得多。&lt;/p&gt;

&lt;p&gt;坦诚。如果有什么不知道，那就明确地表示不知道。如果有什么事情不能说，就明确地表示不能说。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;对事不对人&lt;/h4&gt;

&lt;p&gt;好的团队文化，能不断吸收有益的元素，同时也能保护成员不受偏激和恶意行为的影响。注意要对事不对人，带来负面影响的是行为，而非个人。为一个人定性是很幼稚的想法。需要从团队中剔除和改造的是行为和想法，而非一个个的成员。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;在大组织中发展的一些技巧&lt;/h4&gt;

&lt;p&gt;对不确定的事情提出疑问，不要害怕和上级争论，但一定就事论事。&lt;/p&gt;

&lt;p&gt;在经理问你进展之前，就主动汇报自己在干什么。&lt;/p&gt;

&lt;p&gt;不管技术债务有多少，永远不应该花超过三分之一的时间做防御性的工作，因为这些工作产生不了“看得见”的结果，否则就等于政治自杀。&lt;/p&gt;

&lt;p&gt;沟通的指导原则就是在同步沟通的时候（比如开会），人越少越好。而在异步沟通的时候（比如 Email），涉及的听众越多越好。&lt;/p&gt;

&lt;p&gt;内部沟通强烈推荐采用群聊的方式，这样大家的发言都是当着团队所有人的面。一方面每个人说话前会更慎重，一方面也方便其他人以自己喜欢的方式获取信息。&lt;/p&gt;

&lt;p&gt;不在源代码中署名，因为很多人只能接触到一小块代码，署名会让大家在修改代码时产生更多顾虑。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;我的看法&lt;/h2&gt;

&lt;p&gt;HRT 的着眼点是每个人应该怎么样，而不是团队应该怎么样，所以这些原则适用于任何团队。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;谦虚&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;年纪越大，就越知道自己的局限。知识越丰富，越知道自己的无知。绝大部分时候，我们的想法和行为只是历史洪流中微小的一部分。对自己和对外界的看法，依赖于我们的认知地层，后者又依赖于学识和阅历。回顾过去，当时认为重要的东西，现在看来价值有限。曾经自认为的独一无二的想法，原来只是千万个类似想法中的一个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;尊重&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;“出身”很重要。一个人的发展，很难超越自己的出身太多。总要付出一整个青春的努力，才能进入更高一点的阶层。位于阶层顶部的人，往往是经过了几代人的奋斗，一点一点积累而来。我们的优秀，建立在先辈们的优秀之上。所以和别人比没有意义，起点不同。要和自己比，和先辈们比，看有没有通过努力让自己站得更高，走得更远。&lt;/p&gt;

&lt;p&gt;一人一个活法。每个人有自己的世界观价值观，以自己的狭隘妄自评判别人的生活，是幼稚的。每个人至少能比别人更知道自己想要什么，想过什么样的生活。哪怕想法一样，同样的努力，最终结果也会大相径庭，各有各的难处。成熟的一个表现就是接受差异，尊重不同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;信任&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;人总有长处和短处，哪怕都是长处，时间精力也不能让我们事必躬亲。科学技术的发展，每一件事背后的复杂性大大增加，要做成一件事，越来越依靠协作。组织制度健全程度的一个评判方法，就是你对陌生人有多信任。公司内部也是如此，如果别人辜负了你的信任，最终给对方带来的损失比你自己的更大。&lt;/p&gt;</content><summary type="html">写于 2017-02-18 。

两位作者 Brian W. Fitzpatrick 和 Ben Collins-Sussman 都有在开源项目（Subversion）和大公司（Google）管理工程团队的经验。

作者们认为，优秀的工程师文化的核心是 HRT：谦虚（Humility），尊重（Respect）和信任（Trust）。整本书就是对 HRT 的阐释、示例和应用建议。同时还夹杂着创建维护优秀工程师文化的各种经验和技巧。

主要内容

优秀的个人依托于优秀的团队

现代社会大部分的工作对于单独个体来说已经太过复杂，要把事情做成功，只能依靠协作。应该正确认识社交的意义：“ 社交……是通过建立起人与人之间的关系来把事情做成功，而且这种关系延续的时间肯定比项目本身更长。”

团队文化的定义和维护是每个成员的事，而不仅仅是创始人和负责人的事。关于这一点，拉兹洛·博克在《重新定义团队：谷歌如何工作》中也有类似的观点。他认为“任何人都有能力成为一名创始人，也可以成为所在团队的文化创造者”。

优秀 Leader 的素质

Leader 应该关心做什么而非怎么做，相信团队能自己找的解决问题的方法。设置明确的目标，也是让团队齐心协力的有效方法。最好的激励方式，就是项目对每个成员来说都能够成为内部激励。对于工程师来说，只需提供三样东西：自主、精通和目标。

提问是提供帮助有效形式。Leader 的眼光应该放长。不应只关心这一个问题的解决，而是要帮助成员成长。通过提问的方式一步步引导，让成员依靠自己的力量找到答案，是对他们技术、主人翁意识和责任感的培养。

允许失败。因为 即使失败了，相比于只尝试那些你知道自己肯定能完成，你所得到的会多得多。

坦诚。如果有什么不知道，那就明确地表示不知道。如果有什么事情不能说，就明确地表示不能说。

对事不对人

好的团队文化，能不断吸收有益的元素，同时也能保护成员不受偏激和恶意行为的影响。注意要对事不对人，带来负面影响的是行为，而非个人。为一个人定性是很幼稚的想法。需要从团队中剔除和改造的是行为和想法，而非一个个的成员。

在大组织中发展的一些技巧

对不确定的事情提出疑问，不要害怕和上级争论，但一定就事论事。

在经理问你进展之前，就主动汇报自己在干什么。

不管技术债务有多少，永远不应该花超过三分之一的时间做防御性的工作，因为这些工作产生不了“看得见”的结果，否则就等于政治自杀。

沟通的指导原则就是在同步沟通的时候（比如开会），人越少越好。而在异步沟通的时候（比如 Email），涉及的听众越多越好。

内部沟通强烈推荐采用群聊的方式，这样大家的发言都是当着团队所有人的面。一方面每个人说话前会更慎重，一方面也方便其他人以自己喜欢的方式获取信息。

不在源代码中署名，因为很多人只能接触到一小块代码，署名会让大家在修改代码时产生更多顾虑。

我的看法

HRT 的着眼点是每个人应该怎么样，而不是团队应该怎么样，所以这些原则适用于任何团队。

谦虚

年纪越大，就越知道自己的局限。知识越丰富，越知道自己的无知。绝大部分时候，我们的想法和行为只是历史洪流中微小的一部分。对自己和对外界的看法，依赖于我们的认知地层，后者又依赖于学识和阅历。回顾过去，当时认为重要的东西，现在看来价值有限。曾经自认为的独一无二的想法，原来只是千万个类似想法中的一个。

尊重

“出身”很重要。一个人的发展，很难超越自己的出身太多。总要付出一整个青春的努力，才能进入更高一点的阶层。位于阶层顶部的人，往往是经过了几代人的奋斗，一点一点积累而来。我们的优秀，建立在先辈们的优秀之上。所以和别人比没有意义，起点不同。要和自己比，和先辈们比，看有没有通过努力让自己站得更高，走得更远。

一人一个活法。每个人有自己的世界观价值观，以自己的狭隘妄自评判别人的生活，是幼稚的。每个人至少能比别人更知道自己想要什么，想过什么样的生活。哪怕想法一样，同样的努力，最终结果也会大相径庭，各有各的难处。成熟的一个表现就是接受差异，尊重不同。

信任

人总有长处和短处，哪怕都是长处，时间精力也不能让我们事必躬亲。科学技术的发展，每一件事背后的复杂性大大增加，要做成一件事，越来越依靠协作。组织制度健全程度的一个评判方法，就是你对陌生人有多信任。公司内部也是如此，如果别人辜负了你的信任，最终给对方带来的损失比你自己的更大。</summary></entry><entry><title type="html">《旁观者》读书笔记</title><link href="/reading/2016/12/31/%E6%97%81%E8%A7%82%E8%80%85-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="《旁观者》读书笔记" /><published>2016-12-31T11:30:00+08:00</published><updated>2016-12-31T11:30:00+08:00</updated><id>/reading/2016/12/31/%E3%80%8A%E6%97%81%E8%A7%82%E8%80%85%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/reading/2016/12/31/%E6%97%81%E8%A7%82%E8%80%85-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">&lt;p&gt;写于 2016-12-31 。&lt;/p&gt;

&lt;p&gt;德鲁克在这本书中记录了一些在他生命中留下深刻痕迹的人。没有系统的概念和知识，对于读者，这本书的价值就在于让我们了解到世界上人的多样性，让我们看一看，是什么样的人让德鲁克印象深刻，是什么样的人在影响着这个世界。如果要为这本书归纳一个中心思想，那就是：人很复杂，大部分情况没有好坏，只有差异，管理的最核心理念就是理解人性。&lt;/p&gt;

&lt;p&gt;对同一个目标，途径可以有很多种。 同一件事，可以由个性完全不同的两个人来做，并且都可以做得非常好。管理不应该有定式，而应该因人而异。东方智慧很早就对此深有领悟，于是有了孔子的因材施教，有了禅宗的各种公案。做事情的模式、技巧，只不过是一些较为通用的规则，这些规则施加到不同个性的人身上，效果也可能完全不同。关键在于认清楚目标，然后根据具体的人来不断调整具体的方法。固定的应该是目标，而非方法。&lt;/p&gt;

&lt;p&gt;领导者的核心意义就在于做决策。而关于人的那些决策，又是对一个组织影响最大的。目标不应该是统一和标准，而是多样、包容、协作和平衡。组织像是生物，体内是一个复杂的平衡体系。只有够复杂、够平衡的生物，才能更好地适应环境的变化。&lt;/p&gt;

&lt;p&gt;每个人都有局限性。我们很容易看到别人的局限性，却很难看清楚自己的局限性。
打破局限性，除了自身的努力，更需要机缘。对自己，对别人，都不应该过分要求。有时候不是不够努力，只是没有缘分。
跨过一个局限之后，会看到更大的世界，有些事情变得更简单了，也有些事情变得更复杂了，解决了很多问题，又生出了更多的问题，然后又面临着新的局限性。人生就像山丘，翻过了一座，还有下一座。眼界决定行为，见识越宽，对这个世界看得越清，越能理解本源，也越能看清楚自己的位置和局限，于是做出更好的行为。&lt;/p&gt;

&lt;p&gt;每个时代都有其局限性，每个人除了被自身的局限性限制外，还深处在时代的局限性中，而后者，只有旷世天才才能突破。要求一个人以超越时代的方式思考行为，是无理的，同样，要求一个人一开始就行事妥当，也是不可能的，18岁的人不可能做出50岁的事。&lt;/p&gt;</content><summary type="html">写于 2016-12-31 。

德鲁克在这本书中记录了一些在他生命中留下深刻痕迹的人。没有系统的概念和知识，对于读者，这本书的价值就在于让我们了解到世界上人的多样性，让我们看一看，是什么样的人让德鲁克印象深刻，是什么样的人在影响着这个世界。如果要为这本书归纳一个中心思想，那就是：人很复杂，大部分情况没有好坏，只有差异，管理的最核心理念就是理解人性。

对同一个目标，途径可以有很多种。 同一件事，可以由个性完全不同的两个人来做，并且都可以做得非常好。管理不应该有定式，而应该因人而异。东方智慧很早就对此深有领悟，于是有了孔子的因材施教，有了禅宗的各种公案。做事情的模式、技巧，只不过是一些较为通用的规则，这些规则施加到不同个性的人身上，效果也可能完全不同。关键在于认清楚目标，然后根据具体的人来不断调整具体的方法。固定的应该是目标，而非方法。

领导者的核心意义就在于做决策。而关于人的那些决策，又是对一个组织影响最大的。目标不应该是统一和标准，而是多样、包容、协作和平衡。组织像是生物，体内是一个复杂的平衡体系。只有够复杂、够平衡的生物，才能更好地适应环境的变化。

每个人都有局限性。我们很容易看到别人的局限性，却很难看清楚自己的局限性。
打破局限性，除了自身的努力，更需要机缘。对自己，对别人，都不应该过分要求。有时候不是不够努力，只是没有缘分。
跨过一个局限之后，会看到更大的世界，有些事情变得更简单了，也有些事情变得更复杂了，解决了很多问题，又生出了更多的问题，然后又面临着新的局限性。人生就像山丘，翻过了一座，还有下一座。眼界决定行为，见识越宽，对这个世界看得越清，越能理解本源，也越能看清楚自己的位置和局限，于是做出更好的行为。

每个时代都有其局限性，每个人除了被自身的局限性限制外，还深处在时代的局限性中，而后者，只有旷世天才才能突破。要求一个人以超越时代的方式思考行为，是无理的，同样，要求一个人一开始就行事妥当，也是不可能的，18岁的人不可能做出50岁的事。</summary></entry><entry><title type="html">《成功，动机与目标》读书笔记</title><link href="/reading/2016/12/27/%E6%88%90%E5%8A%9F-%E5%8A%A8%E6%9C%BA%E4%B8%8E%E7%9B%AE%E6%A0%87-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="《成功，动机与目标》读书笔记" /><published>2016-12-27T21:30:00+08:00</published><updated>2016-12-27T21:30:00+08:00</updated><id>/reading/2016/12/27/%E3%80%8A%E6%88%90%E5%8A%9F,%E5%8A%A8%E6%9C%BA%E4%B8%8E%E7%9B%AE%E6%A0%87%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/reading/2016/12/27/%E6%88%90%E5%8A%9F-%E5%8A%A8%E6%9C%BA%E4%B8%8E%E7%9B%AE%E6%A0%87-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">&lt;p&gt;写于 2016-12-27 。&lt;/p&gt;

&lt;p&gt;一开始看到这个书名，还以为是机场书店成功学垃圾，事实上却是一本介绍心理学以及在如何在生活中的应用的好书。书名原文是 “Succeed: How We Reach Our Goals”，这本书也是围绕“目标”这个概念，使用心理学的理论，告诉我们怎样才能设置出合理的目标，让我们更享受达到目标的过程，同时也取得更大的成就。&lt;/p&gt;

&lt;p&gt;人类自以为拥有自我意识，自认为能够通过我们理性的大脑控制自己的行为。但事实并不是这样。众多的实验表明，人类行为会受到来自潜意识的各种心理机制的影响，最终表现往往和理性大脑预想的不一致。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;合理的目标应该是“具体的”，并且有足够的难度&lt;/h3&gt;

&lt;p&gt;具体的目标更容易实现。“尽力而为”或“做到最好”这类模糊的目标，起不到真正的作用，我们需要清楚地知道目标到底是什么样子，时间、地点，越详尽越好。一个技巧是整理出“如果……就……”计划，就是实现想好，当某件事情发生时，我们就去做什么。&lt;/p&gt;

&lt;p&gt;困难的目标才能提升自己。目标应该足够困难（但是能够达到），因为我们往往在达到目标后就松懈了，只有足够难度的目标，才能激发斗志和潜能。《重新定义团队：谷歌如何工作》一书中，提到 Google 鼓励它的员工设立足够大的绩效目标，因为只有想得够大，才能激发出潜力和创新。好的平衡是通过努力，绩效目标能完成70%。绩效考核，也应该看工作本身，而不是看绩效目标有没有完成。我们应该是为了实现一件事而工作，而不是变成为了完成绩效目标而工作。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;两种看待目标的方式：“为什么”和“是什么”&lt;/h3&gt;

&lt;p&gt;面对一件具体的目标，大脑有两种思维方式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;“为什么”方式。试图理解一个行为背后的根本原因。&lt;/li&gt;
  &lt;li&gt;“是什么”方式。具体的行动步骤。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我们需要动力或避免诱惑时，应该用“是什么”方式思考。当我们在做一件困难、生疏或耗时间的事时，“是什么”的思考方式能让我们专注于事物本身。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;两种看待问题的方式：“进取型”和“防御型”&lt;/h3&gt;

&lt;p&gt;对一件事情的思考，可以分为“进取型”和“防御型”。前者是想要变得更好，后者是不想变得更坏。两种思维方式都很有用，前者能带来更多的想象力和创造性思维，后者则带来稳健和准确。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;内在目标和外在目标&lt;/h3&gt;

&lt;p&gt;目标可以分为两种类型：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;“表现型”，注重结果本身。&lt;/li&gt;
  &lt;li&gt;“进步型”，注重对自己的提升。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;聚焦“进步”，能让我们在面对困难时不容易放弃，更不容易抑郁，并让我们更享受达成目标的过程。&lt;/p&gt;

&lt;p&gt;心理上，人类的三种基本需求是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;关联感，指与其他人产生关联，彼此相关。&lt;/li&gt;
  &lt;li&gt;胜任力，指掌握能够完成一些事的技能。&lt;/li&gt;
  &lt;li&gt;自主权，对自己的行为有一定的自由掌控空间。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个目标满足了人的这三个需求，才是真正合适的目标，也会让人们产生所谓&lt;strong&gt;内在动力&lt;/strong&gt;，能让我们拥有更持久的耐力、努力的过程也会更快乐。而有些目标看起来很合理，比如对名利的追求，如果没有契合每个人内心的三种基本需求，那这些目标就是肤浅的、外在的，自然也不能提供持久的动力。为了达到外在目标所付出的努力，给我们带来的往往是更多的苦恼、厌烦和抑郁。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;意志力肌肉&lt;/h3&gt;

&lt;p&gt;意志力就像肌肉，是会疲劳的，同时，也可以通过持续的锻炼让意志力变得更强壮。锻炼的方法是接受一个平时不太愿意做的小的挑战，一点点地坚持下来，意志力肌肉也就会变得越来越强大。和肌肉的使用一样，充分的休息是必须的。&lt;/p&gt;

&lt;p&gt;意志力能够互相感染，所以我们需要仔细地选择工作的环境和共事的人。&lt;/p&gt;</content><summary type="html">写于 2016-12-27 。

一开始看到这个书名，还以为是机场书店成功学垃圾，事实上却是一本介绍心理学以及在如何在生活中的应用的好书。书名原文是 “Succeed: How We Reach Our Goals”，这本书也是围绕“目标”这个概念，使用心理学的理论，告诉我们怎样才能设置出合理的目标，让我们更享受达到目标的过程，同时也取得更大的成就。

人类自以为拥有自我意识，自认为能够通过我们理性的大脑控制自己的行为。但事实并不是这样。众多的实验表明，人类行为会受到来自潜意识的各种心理机制的影响，最终表现往往和理性大脑预想的不一致。

合理的目标应该是“具体的”，并且有足够的难度

具体的目标更容易实现。“尽力而为”或“做到最好”这类模糊的目标，起不到真正的作用，我们需要清楚地知道目标到底是什么样子，时间、地点，越详尽越好。一个技巧是整理出“如果……就……”计划，就是实现想好，当某件事情发生时，我们就去做什么。

困难的目标才能提升自己。目标应该足够困难（但是能够达到），因为我们往往在达到目标后就松懈了，只有足够难度的目标，才能激发斗志和潜能。《重新定义团队：谷歌如何工作》一书中，提到 Google 鼓励它的员工设立足够大的绩效目标，因为只有想得够大，才能激发出潜力和创新。好的平衡是通过努力，绩效目标能完成70%。绩效考核，也应该看工作本身，而不是看绩效目标有没有完成。我们应该是为了实现一件事而工作，而不是变成为了完成绩效目标而工作。

两种看待目标的方式：“为什么”和“是什么”

面对一件具体的目标，大脑有两种思维方式：

  “为什么”方式。试图理解一个行为背后的根本原因。
  “是什么”方式。具体的行动步骤。


当我们需要动力或避免诱惑时，应该用“是什么”方式思考。当我们在做一件困难、生疏或耗时间的事时，“是什么”的思考方式能让我们专注于事物本身。

两种看待问题的方式：“进取型”和“防御型”

对一件事情的思考，可以分为“进取型”和“防御型”。前者是想要变得更好，后者是不想变得更坏。两种思维方式都很有用，前者能带来更多的想象力和创造性思维，后者则带来稳健和准确。

内在目标和外在目标

目标可以分为两种类型：

  “表现型”，注重结果本身。
  “进步型”，注重对自己的提升。


聚焦“进步”，能让我们在面对困难时不容易放弃，更不容易抑郁，并让我们更享受达成目标的过程。

心理上，人类的三种基本需求是：

  关联感，指与其他人产生关联，彼此相关。
  胜任力，指掌握能够完成一些事的技能。
  自主权，对自己的行为有一定的自由掌控空间。


一个目标满足了人的这三个需求，才是真正合适的目标，也会让人们产生所谓内在动力，能让我们拥有更持久的耐力、努力的过程也会更快乐。而有些目标看起来很合理，比如对名利的追求，如果没有契合每个人内心的三种基本需求，那这些目标就是肤浅的、外在的，自然也不能提供持久的动力。为了达到外在目标所付出的努力，给我们带来的往往是更多的苦恼、厌烦和抑郁。

意志力肌肉

意志力就像肌肉，是会疲劳的，同时，也可以通过持续的锻炼让意志力变得更强壮。锻炼的方法是接受一个平时不太愿意做的小的挑战，一点点地坚持下来，意志力肌肉也就会变得越来越强大。和肌肉的使用一样，充分的休息是必须的。

意志力能够互相感染，所以我们需要仔细地选择工作的环境和共事的人。</summary></entry><entry><title type="html">《重构：改善既有代码的设计》读书笔记</title><link href="/reading/2016/12/20/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="《重构：改善既有代码的设计》读书笔记" /><published>2016-12-20T10:30:00+08:00</published><updated>2016-12-20T10:30:00+08:00</updated><id>/reading/2016/12/20/%E3%80%8A%E9%87%8D%E6%9E%84:%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/reading/2016/12/20/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">&lt;p&gt;写于 2016-12-20 。&lt;/p&gt;

&lt;p&gt;早上看完了《重构：改善既有代码的设计》一书。有些失望。或许是这本书面世太久，里面的方法到如今已经成了常识。但总的来说是一本可以快速浏览一遍的书，至少会坚定自己的一个信心：当代码经过自己的手时，它应该变得比之前更好。不要害怕重构，因为重构是一步一步来的，确保步子不太大，确保每一小步的正确性。然后一遍一遍来。花在重构上的时间，从更长的眼光来看，终将会为我们带来更高的开发效率，节省更多的时间。&lt;/p&gt;

&lt;p&gt;我觉得重构的最核心理念是三条，一是更好的可读性，二是更合适的抽象，三是可测试性。&lt;/p&gt;

&lt;p&gt;每个人都知道，代码更多是用来读而非运行的。可读性良好的代码，是优秀程序的基本要求，这个要求其实不低，尤其是在不对地修改迭代中，保持和改善代码的可读性，并不是那么容易。&lt;/p&gt;

&lt;p&gt;我觉得，在可读性之上，建立合适的抽象，这才是程序员应该发挥我们聪明才智的地方。好的抽象能恰到好处地表达出程序的意图，让代码通用、容易扩展维护，同时又不至于抽象得太过导致得不偿失。&lt;/p&gt;

&lt;p&gt;良好的设计应该是测试友好的，你能很容易地为一个方法添加单元测试。测试友好的代码天生就是解耦的鲁棒的，而在自动测试上所多花费的每一分钟，长期来看都会以多得多的回报率带来整体开发效率的提升。&lt;/p&gt;</content><summary type="html">写于 2016-12-20 。

早上看完了《重构：改善既有代码的设计》一书。有些失望。或许是这本书面世太久，里面的方法到如今已经成了常识。但总的来说是一本可以快速浏览一遍的书，至少会坚定自己的一个信心：当代码经过自己的手时，它应该变得比之前更好。不要害怕重构，因为重构是一步一步来的，确保步子不太大，确保每一小步的正确性。然后一遍一遍来。花在重构上的时间，从更长的眼光来看，终将会为我们带来更高的开发效率，节省更多的时间。

我觉得重构的最核心理念是三条，一是更好的可读性，二是更合适的抽象，三是可测试性。

每个人都知道，代码更多是用来读而非运行的。可读性良好的代码，是优秀程序的基本要求，这个要求其实不低，尤其是在不对地修改迭代中，保持和改善代码的可读性，并不是那么容易。

我觉得，在可读性之上，建立合适的抽象，这才是程序员应该发挥我们聪明才智的地方。好的抽象能恰到好处地表达出程序的意图，让代码通用、容易扩展维护，同时又不至于抽象得太过导致得不偿失。

良好的设计应该是测试友好的，你能很容易地为一个方法添加单元测试。测试友好的代码天生就是解耦的鲁棒的，而在自动测试上所多花费的每一分钟，长期来看都会以多得多的回报率带来整体开发效率的提升。</summary></entry><entry><title type="html">Mesos 源码学习(6) Master 和 Slave 之间的消息</title><link href="/mesos/2016/12/08/06_messages_between_master_and_slave.html" rel="alternate" type="text/html" title="Mesos 源码学习(6) Master 和 Slave 之间的消息" /><published>2016-12-08T17:10:00+08:00</published><updated>2016-12-08T17:10:00+08:00</updated><id>/mesos/2016/12/08/06_messages_between_master_and_slave</id><content type="html" xml:base="/mesos/2016/12/08/06_messages_between_master_and_slave.html">&lt;h2 id=&quot;slave--master-&quot;&gt;Slave 向 Master 注册&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;注册总流程&lt;/h3&gt;

&lt;p&gt;Slave 初始化的最后，会做 Recovery ，而 Recovery 的最后，则调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;detector-&amp;gt;detect()&lt;/code&gt; 方法找到
leader master ，找到后，就回调 &lt;code class=&quot;highlighter-rouge&quot;&gt;Slave:detected&lt;/code&gt; 方法。改方法的主要逻辑是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;暂停 StatusUpdateManager&lt;/li&gt;
  &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Slave::authenticate()&lt;/code&gt; 做认证：
    &lt;ol&gt;
      &lt;li&gt;如果正在做 &lt;code class=&quot;highlighter-rouge&quot;&gt;authenticating&lt;/code&gt;，就取消然后返回&lt;/li&gt;
      &lt;li&gt;调用 libprocess 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;link&lt;/code&gt; 方法确保到 master 有一个 link，简单地说就是创建到 master 的一个
长连接。&lt;/li&gt;
      &lt;li&gt;使用默认的或者自定义 module 中的 authenticatee 进行认证&lt;/li&gt;
      &lt;li&gt;认证完成后调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Slave::_authenticate&lt;/code&gt; 方法，该方法：
        &lt;ol&gt;
          &lt;li&gt;如果认证失败，就等待一段 backoff 时间，再次调用 authenticate 做认证；&lt;/li&gt;
          &lt;li&gt;如果认证成功，则调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Slave::doReliableRegistration&lt;/code&gt; 向 master 进行注册，详见见下一节；&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;如果认证超时（写死的5秒），就调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Slave::authenticationTimeout&lt;/code&gt; 方法，该方法会导致重试再一次
认证。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;观察 leader master 的变化，如果 leader 变了，就再次调用一次 &lt;code class=&quot;highlighter-rouge&quot;&gt;Slave::detected&lt;/code&gt; 方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Slave&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;detected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MasterInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_master&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Pause the status updates.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;statusUpdateManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MasterInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;latest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;latest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_master&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;master&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UPID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_master&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Authenticate with the master.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;authenticate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Keep detecting masters.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INFO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Detecting new master&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;detection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;detector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;detect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;latest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onAny&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Slave&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;detected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Slave&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;authenticate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;authenticated&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reliablregistration-&quot;&gt;ReliablRegistration: 可依赖的注册&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Slave::doReliableRegistration&lt;/code&gt; 的主要逻辑如下：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;做一些状态检查，比如当 slave 的状态是 RUNNING 时就直接退出；&lt;/li&gt;
  &lt;li&gt;调用 libprocess 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;link&lt;/code&gt; 方法确保到 master process 有一个长连接；&lt;/li&gt;
  &lt;li&gt;如果 Slave 没有一个 ID，说明这是它的第一次注册，则：
    &lt;ol&gt;
      &lt;li&gt;创建一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;RegisterSlaveMessage&lt;/code&gt; 消息发送给 master process；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;如果 Slave 已经有了一个 ID（比如是 recover 回来的），说明这是 re-register，则：
    &lt;ol&gt;
      &lt;li&gt;创建一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;ReregisterSlaveMessage&lt;/code&gt; 消息&lt;/li&gt;
      &lt;li&gt;把 checkpointed resources，frameworks，tasks 和 executors 等信息填充到消息体中&lt;/li&gt;
      &lt;li&gt;然后把消息发给 master process&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;在适当的 backoff 时间后，再次调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;doReliableRegistration&lt;/code&gt; 方法，这样当 slave 没有正常 run 起来
时，会再次注册，而当 slave 已经 RUNNNIG 时，就完成了注册过程。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Slave&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doReliableRegistration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Duration&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxBackoff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Slave (re-)registered with the master.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Ensure there is a link to the master before we start
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// communicating with it. We want to link after the initial
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// registration backoff in order to avoid all of the agents
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// establishing connections with the master at once.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// See MESOS-5330.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;link&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;master&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;has_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Registering for the first time.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;RegisterSlaveMessage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MESOS_VERSION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutable_slave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CopyFrom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Include checkpointed resources.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutable_checkpointed_resources&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CopyFrom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;checkpointedResources&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;master&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Re-registering, so send tasks running.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;ReregisterSlaveMessage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MESOS_VERSION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutable_checkpointed_resources&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CopyFrom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;checkpointedResources&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutable_slave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CopyFrom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;master&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Slave&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doReliableRegistration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxBackoff&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;master--slave-&quot;&gt;Master 处理 Slave 的注册&lt;/h2&gt;

&lt;p&gt;在 master process 初始化的最后，会注册一些处理方法，来处理不同类型的消息。&lt;/p&gt;

&lt;h3 id=&quot;registerslavemessage-&quot;&gt;第一次注册，处理 RegisterSlaveMessage 消息&lt;/h3&gt;

&lt;p&gt;负责处理 &lt;code class=&quot;highlighter-rouge&quot;&gt;RegisterSlaveMessage&lt;/code&gt; 的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Master::registerSlave&lt;/code&gt; 方法：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RegisterSlaveMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Master&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;registerSlave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RegisterSlaveMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RegisterSlaveMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;checkpointed_resources&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RegisterSlaveMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;masterregisterslave-&quot;&gt;Master::registerSlave 方法&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Master::registerSlave&lt;/code&gt; 方法的主要逻辑是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;检查认证：
    &lt;ol&gt;
      &lt;li&gt;如果该 slave 正在做认证就等一小会儿再次调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;registerSlave&lt;/code&gt; 方法；&lt;/li&gt;
      &lt;li&gt;如果设置了需要认证但 slave 没有通过认证，就向 slave 发送一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;ShutdownMessage&lt;/code&gt; 消息让它自己
关闭；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;如果该 slave 所在的机器被设置为 DOWN 的状态，就向 slave 发送一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;ShutdownMessage&lt;/code&gt; 消息让它自己
关闭。DOWN 的状态用于维护机器，具体参考
&lt;a href=&quot;http://mesos.apache.org/documentation/latest/maintenance/&quot;&gt;Maintenance Primitives&lt;/a&gt; 。&lt;/li&gt;
  &lt;li&gt;如果该 slave 已经注册过了（存在于 &lt;code class=&quot;highlighter-rouge&quot;&gt;slaves.registered&lt;/code&gt; 中），则
    &lt;ol&gt;
      &lt;li&gt;如果已经注册的那个 slave 现在已经没有连接了，就把它移除掉，说明使用了同样地址的一个新的 slave
来注册了。&lt;/li&gt;
      &lt;li&gt;如果已经注册的那个 slave 还在有连接，说明 slave 没有收到注册的 ACK，这时就在给 slave 发送一个
ACK，即发送一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;SlaveRegisteredMessage&lt;/code&gt; 消息，然后退出。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;如果该 slave 正在注册中，则忽略此次消息，直接退出；&lt;/li&gt;
  &lt;li&gt;根据消息内容，创建一个 SlaveInfo ，通过 Registrar 把 SlaveInfo 存起来，然后再调用
&lt;code class=&quot;highlighter-rouge&quot;&gt;Master::_registerSlave&lt;/code&gt; 方法，该方法：
    &lt;ol&gt;
      &lt;li&gt;创建一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Slave&lt;/code&gt; 结构，然后通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;Master::addSlave&lt;/code&gt; 方法把它加入进来。&lt;/li&gt;
      &lt;li&gt;发送给 slave 一个 ACK 消息，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;SlaveRegisteredMessage&lt;/code&gt;。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;masteraddslave-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Master::addSlave&lt;/code&gt; 方法&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Master::addSlave&lt;/code&gt; 方法：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;把这个 Slave 放到 &lt;code class=&quot;highlighter-rouge&quot;&gt;slaves.registered&lt;/code&gt; 结构中；&lt;/li&gt;
  &lt;li&gt;调用 libprocess 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;link&lt;/code&gt; 方法确保从 master 到 slave 有长连接；&lt;/li&gt;
  &lt;li&gt;把这个 slave 的机器放到 &lt;code class=&quot;highlighter-rouge&quot;&gt;machines&lt;/code&gt; 结构中；&lt;/li&gt;
  &lt;li&gt;创建一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;SlaveObserver&lt;/code&gt;（这也是一个 libprocess process），来对这个 Slave 进行观察。
slave observer process 的行为见下一节；&lt;/li&gt;
  &lt;li&gt;把这个 slave 上的 executor 和 task 信息存到 &lt;code class=&quot;highlighter-rouge&quot;&gt;frameworks&lt;/code&gt; 数据结构中；&lt;/li&gt;
  &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;allocator-&amp;gt;addSlave&lt;/code&gt; 方法把这个 slave 加入到 Allocator 中，详见下面。&lt;/li&gt;
  &lt;li&gt;创建一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;AgentAdded&lt;/code&gt; 消息，发给所有订阅者，订阅者的列表维护在 &lt;code class=&quot;highlighter-rouge&quot;&gt;subscribers&lt;/code&gt; 结构中。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;slaveobserver--slave--reachable&quot;&gt;SlaveObserver 负责探测一个 Slave 是否 reachable&lt;/h4&gt;

&lt;p&gt;SlaveObserver 通过 ping-pong 机制。负责探测一个 Slave 是否 reachable。&lt;/p&gt;

&lt;p&gt;这也是一个 libprocess process，它初始化之后就会每隔一小段时间给 slave 发送 &lt;code class=&quot;highlighter-rouge&quot;&gt;PingSlaveMessage&lt;/code&gt;，
Slave 会返回一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;PongSlaveMessage&lt;/code&gt; 。如果没有及时返回，就把这个 slave 标记为 unreachable。&lt;/p&gt;

&lt;p&gt;注意，把 slave 标记为 unreachable 是有速率限制的。&lt;/p&gt;

&lt;p&gt;最终的标记过程由 &lt;code class=&quot;highlighter-rouge&quot;&gt;Master::markUnreachable&lt;/code&gt; 方法实现，主要逻辑是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;更新一下 &lt;code class=&quot;highlighter-rouge&quot;&gt;slaves&lt;/code&gt; 结构，并且通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;registrar&lt;/code&gt; 把一些信息存储下来；&lt;/li&gt;
  &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;allocator-&amp;gt;removeSlave&lt;/code&gt; 方法把 slave 移出 Allocator；&lt;/li&gt;
  &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Master::updateTask&lt;/code&gt; 把该 slave 上的 task 状态设置为 &lt;code class=&quot;highlighter-rouge&quot;&gt;TASK_UNREACHABLE&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;TASK_LOST&lt;/code&gt;。
该方法会创建一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;StatusUpdate&lt;/code&gt; 消息，然后 TODO&lt;/li&gt;
  &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Master::removeTask&lt;/code&gt; 把这个 task remove 掉；&lt;/li&gt;
  &lt;li&gt;把 task 的状态通知它的 framework，也就是把 &lt;code class=&quot;highlighter-rouge&quot;&gt;StatusUpdate&lt;/code&gt; 消息发送给 framework ；&lt;/li&gt;
  &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Master::removeExecutor&lt;/code&gt; 把这个 slave 上的 executor 移除；&lt;/li&gt;
  &lt;li&gt;针对涉及到这个 slave 的 offer，调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;allocator-&amp;gt;recoverResources&lt;/code&gt; recover 这个 offer 的资源，
然后调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Master::removeOffer&lt;/code&gt; 方法把 offer 撤回；&lt;/li&gt;
  &lt;li&gt;针对涉及到这个 slave 的 inverse offer，调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;removeInverseOffer&lt;/code&gt; 把它们 remove 掉；&lt;/li&gt;
  &lt;li&gt;把这个 slave 从 &lt;code class=&quot;highlighter-rouge&quot;&gt;slaves.registered&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;authenticated&lt;/code&gt; 中删除，
添加进 &lt;code class=&quot;highlighter-rouge&quot;&gt;slaves.removed&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;unreachable&lt;/code&gt; 中，把 slave 所在的机器从 &lt;code class=&quot;highlighter-rouge&quot;&gt;machines&lt;/code&gt; 中删除；&lt;/li&gt;
  &lt;li&gt;Terminate 这个 slave 的 observer ；&lt;/li&gt;
  &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sendSlaveLost&lt;/code&gt; 方法，发送一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;LostSlaveMessage&lt;/code&gt; 消息给所有已经注册的 Framework，然后如果
有注册 Hook 的话，调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;masterSlaveLostHook&lt;/code&gt; 。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;reregisterslavemessage-&quot;&gt;重新注册，处理 ReregisterSlaveMessage 消息&lt;/h3&gt;

&lt;p&gt;当一个 slave 重新注册时，会发送一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;ReregisterSlaveMessage&lt;/code&gt; 消息，
该消息由 &lt;code class=&quot;highlighter-rouge&quot;&gt;Master::reregisterSlave&lt;/code&gt; 方法处理：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReregisterSlaveMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Master&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reregisterSlave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReregisterSlaveMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReregisterSlaveMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;checkpointed_resources&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReregisterSlaveMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;executor_infos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReregisterSlaveMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReregisterSlaveMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frameworks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReregisterSlaveMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;completed_frameworks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReregisterSlaveMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;masterreregisterslave-&quot;&gt;Master::reregisterSlave 方法&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Master::reregisterSlave&lt;/code&gt; 方法的主要逻辑是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;检查认证：
    &lt;ol&gt;
      &lt;li&gt;如果该 slave 正在做认证就等一小会儿再次调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;reregisterSlave&lt;/code&gt; 方法；&lt;/li&gt;
      &lt;li&gt;如果设置了需要认证但 slave 没有通过认证，就向 slave 发送一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;ShutdownMessage&lt;/code&gt; 消息让它自己
关闭；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;如果该 slave 所在的机器被设置为 DOWN 的状态，就向 slave 发送一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;ShutdownMessage&lt;/code&gt; 消息让它自己
关闭。DOWN 的状态用于维护机器，具体参考
&lt;a href=&quot;http://mesos.apache.org/documentation/latest/maintenance/&quot;&gt;Maintenance Primitives&lt;/a&gt; 。&lt;/li&gt;
  &lt;li&gt;如果该 slave 已经注册（存在于 &lt;code class=&quot;highlighter-rouge&quot;&gt;slaves.registered&lt;/code&gt; 中），则：
    &lt;ol&gt;
      &lt;li&gt;如果发现这次注册的 hostname 和 ip 和之前注册的不一致，就发送一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;ShutdownMessage&lt;/code&gt; 消息给
slave 让它关闭，然后返回。&lt;/li&gt;
      &lt;li&gt;更新已经 slave process 的 PID，然后调用 libprocess 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;link&lt;/code&gt; 方法创建一个到 slave 的长连接；&lt;/li&gt;
      &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Master::reconcileKnownSlave&lt;/code&gt; 方法进行 reconcile，确保 master 和 slave 上保存的 task 
一致，TODO&lt;/li&gt;
      &lt;li&gt;如果这是一个 disconnected 的 slave ：
        &lt;ol&gt;
          &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;SlaveObserver::reconnect&lt;/code&gt; 方法重新连接，&lt;/li&gt;
          &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;allocator-&amp;gt;activateSlave&lt;/code&gt; 方法让这个 slave 在 Allocator 中重新 active 。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Master::__reregisterSlave&lt;/code&gt; 方法，告诉 slave master 的 version，以及新的 framework PID，
然后退出；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;如果该 slave 正在注册，就忽略本次消息，然后退出；&lt;/li&gt;
  &lt;li&gt;如果该 slave 即没有注册也没有正在注册，通常情况下是由于这个 slave unreachable 了。这是就通过
&lt;code class=&quot;highlighter-rouge&quot;&gt;registrar&lt;/code&gt; 把 slave 的信息存储下来，然后调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Master::_reregisterSlave&lt;/code&gt; 方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;masterreregisterslave--1&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Master::_reregisterSlave&lt;/code&gt; 方法&lt;/h5&gt;

&lt;p&gt;主要逻辑是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Master::addSlave&lt;/code&gt; 方法把 slave 加进来；&lt;/li&gt;
  &lt;li&gt;在 Mesos 1.1.0 版本中，新引入了实验性的 partition-aware 特性，具体可以参考：
&lt;a href=&quot;http://mesos.apache.org/blog/mesos-1-1-0-released/&quot;&gt;Apache Mesos 1.1.0 Released&lt;/a&gt; 。
在这里，如果这个 slave 是由当前这个 master remove 掉的，那么对于没有设置 partition-aware 的
framework，就发送一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;ShutdownFrameworkMessage&lt;/code&gt; 消息给 slave 让它关闭这个 framework ，也就是
把 slave 上这个 framework 的所有 task 杀掉。&lt;/li&gt;
  &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Master::__reregisterSlave&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;masterreregisterslave--2&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Master::__reregisterSlave&lt;/code&gt; 方法&lt;/h5&gt;

&lt;h4 id=&quot;masterreconcileknownslave-&quot;&gt;Master::reconcileKnownSlave 方法&lt;/h4&gt;

&lt;h2 id=&quot;slavestatusupdate-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Slave::statusUpdate&lt;/code&gt; 方法。&lt;/h2&gt;</content><summary type="html">Slave 向 Master 注册

注册总流程

Slave 初始化的最后，会做 Recovery ，而 Recovery 的最后，则调用 detector-&amp;gt;detect() 方法找到
leader master ，找到后，就回调 Slave:detected 方法。改方法的主要逻辑是：


  暂停 StatusUpdateManager
  调用 Slave::authenticate() 做认证：
    
      如果正在做 authenticating，就取消然后返回
      调用 libprocess 中的 link 方法确保到 master 有一个 link，简单地说就是创建到 master 的一个
长连接。
      使用默认的或者自定义 module 中的 authenticatee 进行认证
      认证完成后调用 Slave::_authenticate 方法，该方法：
        
          如果认证失败，就等待一段 backoff 时间，再次调用 authenticate 做认证；
          如果认证成功，则调用 Slave::doReliableRegistration 向 master 进行注册，详见见下一节；
        
      
      如果认证超时（写死的5秒），就调用 Slave::authenticationTimeout 方法，该方法会导致重试再一次
认证。
    
  
  观察 leader master 的变化，如果 leader 变了，就再次调用一次 Slave::detected 方法。


void Slave::detected(const Future&amp;lt;Option&amp;lt;MasterInfo&amp;gt;&amp;gt;&amp;amp; _master)
{
  ...
  // Pause the status updates.
  statusUpdateManager-&amp;gt;pause();
  ...
  Option&amp;lt;MasterInfo&amp;gt; latest;
  ...
  latest = _master.get();
  master = UPID(_master.get().get().pid());
  ...
  // Authenticate with the master.
  authenticate();
  ...
  // Keep detecting masters.
  LOG(INFO) &amp;lt;&amp;lt; &quot;Detecting new master&quot;;
  detection = detector-&amp;gt;detect(latest)
    .onAny(defer(self(), &amp;amp;Slave::detected, lambda::_1));
}
...

void Slave::authenticate()
{
  authenticated = false;
  ...
  




ReliablRegistration: 可依赖的注册

Slave::doReliableRegistration 的主要逻辑如下：

  做一些状态检查，比如当 slave 的状态是 RUNNING 时就直接退出；
  调用 libprocess 的 link 方法确保到 master process 有一个长连接；
  如果 Slave 没有一个 ID，说明这是它的第一次注册，则：
    
      创建一个 RegisterSlaveMessage 消息发送给 master process；
    
  
  如果 Slave 已经有了一个 ID（比如是 recover 回来的），说明这是 re-register，则：
    
      创建一个 ReregisterSlaveMessage 消息
      把 checkpointed resources，frameworks，tasks 和 executors 等信息填充到消息体中
      然后把消息发给 master process
    
  
  在适当的 backoff 时间后，再次调用 doReliableRegistration 方法，这样当 slave 没有正常 run 起来
时，会再次注册，而当 slave 已经 RUNNNIG 时，就完成了注册过程。


void Slave::doReliableRegistration(Duration maxBackoff)
{
  ...
    if (state == RUNNING) { // Slave (re-)registered with the master.
    return;
  }
  ...
  // Ensure there is a link to the master before we start
  // communicating with it. We want to link after the initial
  // registration backoff in order to avoid all of the agents
  // establishing connections with the master at once.
  // See MESOS-5330.
  link(master.get());
  
    if (!info.has_id()) {
    // Registering for the first time.
    RegisterSlaveMessage message;
    message.set_version(MESOS_VERSION);
    message.mutable_slave()-&amp;gt;CopyFrom(info);

    // Include checkpointed resources.
    message.mutable_checkpointed_resources()-&amp;gt;CopyFrom(checkpointedResources);

    send(master.get(), message);
  } else {
    // Re-registering, so send tasks running.
    ReregisterSlaveMessage message;
    message.set_version(MESOS_VERSION);
	...
	message.mutable_checkpointed_resources()-&amp;gt;CopyFrom(checkpointedResources);
	message.mutable_slave()-&amp;gt;CopyFrom(info);
	...
	send(master.get(), message);
  }
  ...
  process::delay(delay, self(), &amp;amp;Slave::doReliableRegistration, maxBackoff * 2);
}



Master 处理 Slave 的注册

在 master process 初始化的最后，会注册一些处理方法，来处理不同类型的消息。

第一次注册，处理 RegisterSlaveMessage 消息

负责处理 RegisterSlaveMessage 的是 Master::registerSlave 方法：

  install&amp;lt;RegisterSlaveMessage&amp;gt;(
      &amp;amp;Master::registerSlave,
      &amp;amp;RegisterSlaveMessage::slave,
      &amp;amp;RegisterSlaveMessage::checkpointed_resources,
      &amp;amp;RegisterSlaveMessage::version);



Master::registerSlave 方法

Master::registerSlave 方法的主要逻辑是：

  检查认证：
    
      如果该 slave 正在做认证就等一小会儿再次调用 registerSlave 方法；
      如果设置了需要认证但 slave 没有通过认证，就向 slave 发送一个 ShutdownMessage 消息让它自己
关闭；
    
  
  如果该 slave 所在的机器被设置为 DOWN 的状态，就向 slave 发送一个 ShutdownMessage 消息让它自己
关闭。DOWN 的状态用于维护机器，具体参考
Maintenance Primitives 。
  如果该 slave 已经注册过了（存在于 slaves.registered 中），则
    
      如果已经注册的那个 slave 现在已经没有连接了，就把它移除掉，说明使用了同样地址的一个新的 slave
来注册了。
      如果已经注册的那个 slave 还在有连接，说明 slave 没有收到注册的 ACK，这时就在给 slave 发送一个
ACK，即发送一个 SlaveRegisteredMessage 消息，然后退出。
    
  
  如果该 slave 正在注册中，则忽略此次消息，直接退出；
  根据消息内容，创建一个 SlaveInfo ，通过 Registrar 把 SlaveInfo 存起来，然后再调用
Master::_registerSlave 方法，该方法：
    
      创建一个 Slave 结构，然后通过 Master::addSlave 方法把它加入进来。
      发送给 slave 一个 ACK 消息，即 SlaveRegisteredMessage。
    
  


Master::addSlave 方法

Master::addSlave 方法：

  把这个 Slave 放到 slaves.registered 结构中；
  调用 libprocess 的 link 方法确保从 master 到 slave 有长连接；
  把这个 slave 的机器放到 machines 结构中；
  创建一个 SlaveObserver（这也是一个 libprocess process），来对这个 Slave 进行观察。
slave observer process 的行为见下一节；
  把这个 slave 上的 executor 和 task 信息存到 frameworks 数据结构中；
  调用 allocator-&amp;gt;addSlave 方法把这个 slave 加入到 Allocator 中，详见下面。
  创建一个 AgentAdded 消息，发给所有订阅者，订阅者的列表维护在 subscribers 结构中。


SlaveObserver 负责探测一个 Slave 是否 reachable

SlaveObserver 通过 ping-pong 机制。负责探测一个 Slave 是否 reachable。

这也是一个 libprocess process，它初始化之后就会每隔一小段时间给 slave 发送 PingSlaveMessage，
Slave 会返回一个 PongSlaveMessage 。如果没有及时返回，就把这个 slave 标记为 unreachable。

注意，把 slave 标记为 unreachable 是有速率限制的。

最终的标记过程由 Master::markUnreachable 方法实现，主要逻辑是：

  更新一下 slaves 结构，并且通过 registrar 把一些信息存储下来；
  调用 allocator-&amp;gt;removeSlave 方法把 slave 移出 Allocator；
  调用 Master::updateTask 把该 slave 上的 task 状态设置为 TASK_UNREACHABLE 或 TASK_LOST。
该方法会创建一个 StatusUpdate 消息，然后 TODO
  调用 Master::removeTask 把这个 task remove 掉；
  把 task 的状态通知它的 framework，也就是把 StatusUpdate 消息发送给 framework ；
  调用 Master::removeExecutor 把这个 slave 上的 executor 移除；
  针对涉及到这个 slave 的 offer，调用 allocator-&amp;gt;recoverResources recover 这个 offer 的资源，
然后调用 Master::removeOffer 方法把 offer 撤回；
  针对涉及到这个 slave 的 inverse offer，调用 removeInverseOffer 把它们 remove 掉；
  把这个 slave 从 slaves.registered 和 authenticated 中删除，
添加进 slaves.removed 和 unreachable 中，把 slave 所在的机器从 machines 中删除；
  Terminate 这个 slave 的 observer ；
  调用 sendSlaveLost 方法，发送一个 LostSlaveMessage 消息给所有已经注册的 Framework，然后如果
有注册 Hook 的话，调用 masterSlaveLostHook 。


重新注册，处理 ReregisterSlaveMessage 消息

当一个 slave 重新注册时，会发送一个 ReregisterSlaveMessage 消息，
该消息由 Master::reregisterSlave 方法处理：

  install&amp;lt;ReregisterSlaveMessage&amp;gt;(
      &amp;amp;Master::reregisterSlave,
      &amp;amp;ReregisterSlaveMessage::slave,
      &amp;amp;ReregisterSlaveMessage::checkpointed_resources,
      &amp;amp;ReregisterSlaveMessage::executor_infos,
      &amp;amp;ReregisterSlaveMessage::tasks,
      &amp;amp;ReregisterSlaveMessage::frameworks,
      &amp;amp;ReregisterSlaveMessage::completed_frameworks,
      &amp;amp;ReregisterSlaveMessage::version);



Master::reregisterSlave 方法

Master::reregisterSlave 方法的主要逻辑是：

  检查认证：
    
      如果该 slave 正在做认证就等一小会儿再次调用 reregisterSlave 方法；
      如果设置了需要认证但 slave 没有通过认证，就向 slave 发送一个 ShutdownMessage 消息让它自己
关闭；
    
  
  如果该 slave 所在的机器被设置为 DOWN 的状态，就向 slave 发送一个 ShutdownMessage 消息让它自己
关闭。DOWN 的状态用于维护机器，具体参考
Maintenance Primitives 。
  如果该 slave 已经注册（存在于 slaves.registered 中），则：
    
      如果发现这次注册的 hostname 和 ip 和之前注册的不一致，就发送一个 ShutdownMessage 消息给
slave 让它关闭，然后返回。
      更新已经 slave process 的 PID，然后调用 libprocess 的 link 方法创建一个到 slave 的长连接；
      调用 Master::reconcileKnownSlave 方法进行 reconcile，确保 master 和 slave 上保存的 task 
一致，TODO
      如果这是一个 disconnected 的 slave ：
        
          调用 SlaveObserver::reconnect 方法重新连接，
          调用 allocator-&amp;gt;activateSlave 方法让这个 slave 在 Allocator 中重新 active 。
        
      
      调用 Master::__reregisterSlave 方法，告诉 slave master 的 version，以及新的 framework PID，
然后退出；
    
  
  如果该 slave 正在注册，就忽略本次消息，然后退出；
  如果该 slave 即没有注册也没有正在注册，通常情况下是由于这个 slave unreachable 了。这是就通过
registrar 把 slave 的信息存储下来，然后调用 Master::_reregisterSlave 方法。


Master::_reregisterSlave 方法

主要逻辑是：

  调用 Master::addSlave 方法把 slave 加进来；
  在 Mesos 1.1.0 版本中，新引入了实验性的 partition-aware 特性，具体可以参考：
Apache Mesos 1.1.0 Released 。
在这里，如果这个 slave 是由当前这个 master remove 掉的，那么对于没有设置 partition-aware 的
framework，就发送一个 ShutdownFrameworkMessage 消息给 slave 让它关闭这个 framework ，也就是
把 slave 上这个 framework 的所有 task 杀掉。
  调用 Master::__reregisterSlave 方法


Master::__reregisterSlave 方法

Master::reconcileKnownSlave 方法

Slave::statusUpdate 方法。</summary></entry></feed>
