<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>做美好的人，做酷的事</title>
    <description>记录所学所想
</description>
    <link>http://gaopenghigh.github.io/</link>
    <atom:link href="http://gaopenghigh.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 17 Feb 2020 21:09:09 +0800</pubDate>
    <lastBuildDate>Mon, 17 Feb 2020 21:09:09 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title></title>
        <description>&lt;h1 id=&quot;linux-内存管理9-回收页框&quot;&gt;Linux 内存管理(9): 回收页框&lt;/h1&gt;

&lt;p&gt;在&lt;a href=&quot;2013-11-10-mm_07_page_cache.md&quot;&gt;“页高速缓存”&lt;/a&gt;一文中简单介绍了页高速缓存的回收：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当物理内存空间紧张时，内核需要把已经缓存着的内容选择一部分清除。内核首先会选择
干净的（不脏的）页面进行替换。当没有足够的干净页面时，内核就通过所谓预测算法来
会找出那些以后最不可能使用的页面。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;LRU算法&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;我们先了解一下缓存中的LRU算法，或者叫“最近最少使用算法。可以把LRU算法理解成一个
链表，每访问一个页就把该页加到链表的尾部，而清理总是选择链表头部的页来做。这种
方式有个问题：如果我们有一些只会访问一次的文件，按照LRU算法这些文件也会被缓存，
但显然这些文件不应该被缓存才对。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;双链策略和LRU/n算法&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;Linux使用的是一个修改过的LRU算法，叫做双链策略。内核维护了两个链表：活跃链表和
非活跃链表。处于活跃链表上的内容被认为是”热“的且不会被换出，而在非活跃链表上的
页面则是可以被换出的。在活跃链表中的页面必须在其被访问时就处于非活跃链表中。两
个链表都被“伪LRU”规则维护：页面从尾部加入，从头部移除。两个链表需要维持平衡——
如果活跃链表变得过多而超过了非活跃链表，那么活跃链表的头页面将被重新移到非活跃
链表中以便能再被回收。这种双链表的方式也称为LRU/2。更普遍的方式是n个链表，称为
LRU/n。&lt;/p&gt;

  &lt;p&gt;缓存中的页来自对文件的读写，包括普通文件，块设备文件和内存映射文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文从整体的角度梳理一下Linux内核对页框的回收。&lt;/p&gt;

&lt;h2 id=&quot;页框回收算法pfra&quot;&gt;页框回收算法PFRA&lt;/h2&gt;

&lt;p&gt;随着系统不断允许，迟早所有的空闲内存将被分配给进程和高速缓存。Linux内核的页框
回收算法（page frame reclaiming algorithm, PFRA）采取从用户态进程和页高速缓存
“窃取”页框的方法，补充伙伴系统的空闲列表。&lt;/p&gt;

&lt;p&gt;根据页框的内容，可以把页框分为4类：不可回收页，可交换页，可同步页和可丢弃页。
具体如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不可回收页&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不可回收页不允许也无需回收。包括空闲页、保留页、内核动态分配页、进程内核态堆栈
页，临时锁定页，内存锁定页。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;可交换页&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于可交换页，必要时会把页的内容保存在交换区（swap）。包括用户态地址空间的匿名
页，tmpfs文件系统的映射页（比如IPC共享内存的页）。所谓匿名页，是指它属于一个进
程的某个匿名VMA，比如，进程的用户态堆和栈中的页都为匿名页。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;可同步页&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于可同步页，必要时，与硬盘映像同步这些页。包括用户态地址空间的映射页，存有磁
盘文件数据且在页高速缓存中的页，块设备缓冲区页，某些磁盘高速缓存的页（如索引节
点高速缓存）。所谓映射页就是指该页映射了一个文件的某个部分。同步时，需要检查页
是否为脏，必要是需要把页的内容写回到硬盘中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;可丢弃页&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于可丢弃页无需操作。包括内存高速缓存中未使用的页（如slab分配器高速缓存），目
录项高速缓存的为使用页。&lt;/p&gt;

&lt;p&gt;粗略地说，任何属于磁盘和内存高速缓存的页，以及属于进程用户态地址空间的页，都是
可回收的。&lt;/p&gt;

&lt;p&gt;当PFRA必须回收属于某进程用户态地址空间爱你的页框时，它必须考虑页框是否是共享的
。当进程创建子进程时，父子进程就共享一些页框。另外当多个进程以内存映射的方式访
问同一个文件时，这部分页框也是共享的。&lt;/p&gt;

&lt;h3 id=&quot;页框回收算法总的原则&quot;&gt;页框回收算法总的原则&lt;/h3&gt;

&lt;p&gt;页框回收算法是一种相当经验性的工作，很少有理论支持。PFRA的实现也非常复杂。我们
主要看看在PFRA采用的几个总的原则。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;释放“无害”的页&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在回收进程用户态地址空间之前，必须先回收磁盘与内存高速缓存中的页。因为回收这些
页并不需要修改任何页表项。上面介绍的“双链策略和LRU/n算法”正是用来回收页高速缓存
中的页框的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;将用户态进程哦所有页定位可回收页&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;除了锁定页，PFRA必须能够窃取任何用户态进程页，包括匿名页。这样，睡眠较长时间的
进程将逐渐失去所有页框。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;同时取消引用一个共享页框的所有页表项的映射，就可以回收该共享页框&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当PFRA要释放几个进程共享的页框时，它就清空引用该页框的所有页表项，然后回收该
页框。至于怎么找到共享一个页框的所有页表项，我们下面再看。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;只回收“未用”页&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PFRA把页框分为“在用(in_use)”和“未用(unused)”，类似页与上面介绍的LRU算法的双链。
思想就是：如果某页很长时间没有访问，那么它将来被访问的可能性较小，就可以将它看
作未用;如果某页最近被访问过，那么它将来被访问的可能性较大，就把它看作在用。&lt;/p&gt;

&lt;h3 id=&quot;反向映射&quot;&gt;反向映射&lt;/h3&gt;

&lt;p&gt;下面我们看看怎么找到共享一个页框的所有页表项。内核中使用所谓“反向映射”的技术来
实现这一点。简单地说，反向映射就是通过一系列的链接，让内核能够方便地从一个页框
找到所有指向这个页框的页表项。&lt;/p&gt;

&lt;h4 id=&quot;映射页的反向映射&quot;&gt;映射页的反向映射&lt;/h4&gt;

&lt;p&gt;首先，页(struct page)结构中有这样一个字段&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct address_space *mapping
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它就指向这个页属于的&lt;code class=&quot;highlighter-rouge&quot;&gt;address_space&lt;/code&gt;，而在&lt;code class=&quot;highlighter-rouge&quot;&gt;struct address_space&lt;/code&gt;中又包含了o&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct prio_tree_root   i_mmap;   /* tree of private and shared mappings */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;i_mmap&lt;/code&gt;指向的树又包含了所有映射到这个&lt;code class=&quot;highlighter-rouge&quot;&gt;address_space&lt;/code&gt;的VMA。而在VMA的结构
&lt;code class=&quot;highlighter-rouge&quot;&gt;struct vm_area_struct&lt;/code&gt;中又有&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct mm_struct * vm_mm;    /* 关联的mm_struct. */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;指向了进程的内存描述符&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;，从&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;就能找到页全局目录：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pgd_t  *pgd;           /* 页全局目录 */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样一步步“反向映射”过来，就能通过一个页框，找到所有指向这个页框的页表项。&lt;/p&gt;

&lt;h4 id=&quot;匿名页的反向映射&quot;&gt;匿名页的反向映射&lt;/h4&gt;

&lt;p&gt;匿名映射经常是由几个进程共享的，比如在创建子进程时，父进程的所有页框，包括匿名
页，同时也分配给子进程。&lt;/p&gt;

&lt;p&gt;将引用同一个页框的所有匿名页链接起来的策略很简单，就是把该页框所在的匿名VMA存放
在一个双向循环列表中。不过需要注意的是，即使一个VMA中包含了不同的页，也只有一个
双链表用把匿名VMA链接起来，该链表就被用于该VMA中的所有页。&lt;/p&gt;

&lt;p&gt;让我们具体来看一看。&lt;/p&gt;

&lt;p&gt;当为一个匿名VMA分配第一页时，内核创建一个新的&lt;code class=&quot;highlighter-rouge&quot;&gt;anon_vma&lt;/code&gt;
数据结构，它代表了VMA双向循环列表的头。然后内核把这个VMA插入到链表中。在
&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_area_struct&lt;/code&gt;结构中有两个字段&lt;code class=&quot;highlighter-rouge&quot;&gt;anon_vma_node&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;anon_vma&lt;/code&gt;，前者指向了链表
中的前后匿名VMA，后者指向了链表的头。最后，内核把&lt;code class=&quot;highlighter-rouge&quot;&gt;anon_vma&lt;/code&gt;即链表头的位置放到了
页描述符&lt;code class=&quot;highlighter-rouge&quot;&gt;struct page&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mapping&lt;/code&gt;字段。&lt;/p&gt;

&lt;p&gt;当已经被一个进程引用的页框插入另一个进程的页表项时（比如使用fork()系统调用时）
，内核就把第二个进程的匿名VMA插入第一个进程匿名VMA所在的链表中。&lt;/p&gt;

&lt;p&gt;匿名页的反向映射结构图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/reverse_mapping_for_anonymous_pages.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;交换swapping&quot;&gt;交换(swapping)&lt;/h2&gt;

&lt;h3 id=&quot;原理&quot;&gt;原理&lt;/h3&gt;

&lt;p&gt;交换(swapping)用来为非映射页在磁盘上提供备份。有三类页
需要由交换子系统处理:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;属于进程匿名VMA（如用户态堆和栈）的页。&lt;/li&gt;
  &lt;li&gt;属于进程私有内存映射的脏页。&lt;/li&gt;
  &lt;li&gt;属于IPC共享内存区的页。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;交换对于程序是透明的。大概原理如下：&lt;/p&gt;

&lt;p&gt;每个页表项有一个P标志（Present标志），
这个标志表示这个内存页当前是否在物理内存中，内核通过这个标志就知道这个页是否被
换出(swap out)。除了这个标志，内核还利用页表项中的其他位来存放换出页标识符(
swapped-out page identifier)。该标识符用于编码换出页在磁盘上的位置。当缺页异常
发生时，相应的异常处理程序可以检测到该页不再RAM中，然后调用函数从磁盘换入需该
缺页。&lt;/p&gt;

&lt;h3 id=&quot;交换区&quot;&gt;交换区&lt;/h3&gt;

&lt;p&gt;从内存中换出的页存放在交换区（swap area）中。交换区可以是一个磁盘分区，也可以是
一个文件，一个系统可以定义多种不同的交换区。&lt;/p&gt;

&lt;p&gt;每个交换区都由一组页槽（page slot）组成，所谓页槽就是只页大小（一般4096字节）的
块，每快中包含一个换出的页。交换区的第一个页槽用来永久存放有关交换区的信息。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/6097773/&quot;&gt;Linux内核设计与实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://oss.org.cn/kernel-book/ch06/6.3.1.htm&quot;&gt;深入分析Linux内核源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/2287506/&quot;&gt;深入理解Linux内核&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.win.tue.nl/~aeb/linux/lk/lk.html&quot;&gt;The Linux Kernel&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory&quot;&gt;Anatomy of a Program in Memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation&quot;&gt;Memory Translation and Segmentation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory&quot;&gt;How The Kernel Manages Your Memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/category/linux&quot;&gt;Page Cache, the Affair Between Memory and Files&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/the-thing-king&quot;&gt;The Thing King&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection&quot;&gt;CPU Rings, Privilege, and Protection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 17 Feb 2020 21:09:09 +0800</pubDate>
        <link>http://gaopenghigh.github.io/2020/02/17/2013-11-12-mm_09_page_frame_reclaiming.html</link>
        <guid isPermaLink="true">http://gaopenghigh.github.io/2020/02/17/2013-11-12-mm_09_page_frame_reclaiming.html</guid>
        
        
      </item>
    
      <item>
        <title></title>
        <description>&lt;h1 id=&quot;linux-内存管理8-内存映射&quot;&gt;Linux 内存管理(8): 内存映射&lt;/h1&gt;

&lt;p&gt;上一篇讨论“页页高速缓存中”说过：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;read()&lt;/code&gt;调用首先把数据从磁盘拷贝到page cache，再从page cache拷贝到用户空间，
发生了两次拷贝。通过&lt;strong&gt;内存映射文件（Memory-mapped files)&lt;/strong&gt;可以避免这个问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;内存映射&quot;&gt;内存映射&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;img/mappedFileRead.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当使用内存映射文件时，内核把程序的虚拟页直接map到page cache。但不是所有内容都
马上从磁盘读取到物理内存中，而是通过 page fault ，在需要的时候才从磁盘读取。&lt;/p&gt;

&lt;p&gt;文件映射有两种类型：&lt;strong&gt;私有的(private)&lt;/strong&gt;或者是&lt;strong&gt;共享的(shared)&lt;/strong&gt;，它们的区别只有
在内容被更新时才能体现出来。通过在mmap()系统调用中指定&lt;code class=&quot;highlighter-rouge&quot;&gt;MAP_SHARED&lt;/code&gt;标志或者
&lt;code class=&quot;highlighter-rouge&quot;&gt;MAP_PRIVARITE&lt;/code&gt;标志来表示不同类型的映射。&lt;/p&gt;

&lt;p&gt;如果是共享的，进程对映射中的一个页进行写，则这种
修改对于映射了这同一个文件的所有进程来说都是可见的。&lt;/p&gt;

&lt;p&gt;当进程创建的映射只是为读文件，而不是写文件时才会使用似有映射。如果是私有映射，
对内容的更新不会回写到磁盘，其它map此文件的进程也看不到。这是通过&lt;strong&gt;写时复制&lt;/strong&gt;机
制保证的。&lt;/p&gt;

&lt;p&gt;共享内存映射的页通常都包含在页高速缓存中，私有内存映射的页只要还没有被修改，也
都包含在页高速缓存中。当进程试图修改一个私有内存映射的页时，内核就把该页框进行
复制，并在进程页表中用复制的页来替换原来的页框。这就是所谓的“写时复制”机制。&lt;/p&gt;

&lt;p&gt;下图中的两个进程，reander有读写操作，3dreander只有读，他们都通过私有的方式映射
了文件 scene.dat ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/copyOnWrite.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;动态加载的库文件就是通过文件映射映射到进程空间的，一副“全景图”如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/virtualToPhysicalMapping.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;内存映射的数据结构&quot;&gt;内存映射的数据结构&lt;/h3&gt;

&lt;p&gt;内存映射可以用下列数据结构的组合来表示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;与所映射的文件相关的inode对象&lt;/li&gt;
  &lt;li&gt;所映射文件的&lt;code class=&quot;highlighter-rouge&quot;&gt;address_space&lt;/code&gt;对象&lt;/li&gt;
  &lt;li&gt;不同进程对一个文件进行不同映射所使用的文件对象&lt;/li&gt;
  &lt;li&gt;对文件进行每一个不同映射所使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_area_struct&lt;/code&gt;描述符&lt;/li&gt;
  &lt;li&gt;对文件进行映射的VMA所分配的每个页框所对应的页描述符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图说明了这些数据结构是如何链接在一起的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/mmap_data_structure.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中，inode的&lt;code class=&quot;highlighter-rouge&quot;&gt;i_mapping&lt;/code&gt;字段指向文件的&lt;code class=&quot;highlighter-rouge&quot;&gt;address_space&lt;/code&gt;对象。每个&lt;code class=&quot;highlighter-rouge&quot;&gt;address_space&lt;/code&gt;
对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;page_tree&lt;/code&gt;字段又指向该地址空间的页的基树(page_tree)，另外&lt;code class=&quot;highlighter-rouge&quot;&gt;i_mmap&lt;/code&gt;字段指
向第二课树，即由VMA组成的radix优先级搜索树。参考前文
&lt;a href=&quot;2013-11-10-mm_07_page_cache.md&quot;&gt;“页高速缓存”&lt;/a&gt;。每个&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_area_struct&lt;/code&gt;都有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_file&lt;/code&gt;字段，
与所映射的文件对象链接（如果该字段为NULL，则VMA没有用于内存映射）。第一个映射
单元的位置，即以页大小作为单位的偏移量，存放在&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_area_struct&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_pgoff&lt;/code&gt;字
段，所映射的文件部分的长度就是VMA的大小，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_start&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_end&lt;/code&gt;计算出来。&lt;/p&gt;

&lt;p&gt;内存映射最终也是通过“缺页异常”来工作的。事实上，一个新建立的内存映射就是一个不
包含任何页的VMA。当进程引用VMA中的一个地址时，缺页异常发生，缺页异常中断处理程
序检查线性区的nopage方法是否定义。如果没有定义nopage，则说明VMA不映射磁盘上的文
件;否则，进行映射，通过访问块设备处理读取的页。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/6097773/&quot;&gt;Linux内核设计与实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://oss.org.cn/kernel-book/ch06/6.3.1.htm&quot;&gt;深入分析Linux内核源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/2287506/&quot;&gt;深入理解Linux内核&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.win.tue.nl/~aeb/linux/lk/lk.html&quot;&gt;The Linux Kernel&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory&quot;&gt;Anatomy of a Program in Memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation&quot;&gt;Memory Translation and Segmentation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory&quot;&gt;How The Kernel Manages Your Memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/category/linux&quot;&gt;Page Cache, the Affair Between Memory and Files&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/the-thing-king&quot;&gt;The Thing King&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection&quot;&gt;CPU Rings, Privilege, and Protection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 17 Feb 2020 21:09:09 +0800</pubDate>
        <link>http://gaopenghigh.github.io/2020/02/17/2013-11-11-mm_08_mmap.html</link>
        <guid isPermaLink="true">http://gaopenghigh.github.io/2020/02/17/2013-11-11-mm_08_mmap.html</guid>
        
        
      </item>
    
      <item>
        <title></title>
        <description>&lt;h1 id=&quot;linux-内存管理7-页高速缓存&quot;&gt;Linux 内存管理(7): 页高速缓存&lt;/h1&gt;

&lt;p&gt;到目前为止我们知道的工作方式是：&lt;/p&gt;

&lt;p&gt;内核有自己的内核空间，每个进程都有完整的虚拟空间。进程需要有一些匿名VMA，来存
Heap, Stack等等，还需要一些文件VMA，映射一些库文件或者是需要读写的文件。
进程对内容的变更，一开始只发生在虚拟空间，只是对VMA做一些修改或创建。
VMA下的虚拟内存以“虚拟页”为单位管理，虚拟页的大小和物理页一样，虚拟页通过“页表”
来找到对应的物理页。如果找不到，说明当前需要操作的内容不在物理内存中，于是内核
通过分配物理内存，或者映射文件到物理内存，这时才是对物理内存的真的操作。
“物理页”或者简单地说“页”是内核管理物理内存的单位。内核需要满足很多进程的需要以
及自身的需要，通过 “page fault” 的方式，把合适的内容放到物理内存中。&lt;/p&gt;

&lt;p&gt;现在我们的问题是：&lt;/p&gt;

&lt;p&gt;物理内存很小，可能小于单个进程的虚拟空间大小，内核如何让多进程共享这一块地方？
硬盘的速度比内存慢好几个数量级，内核如何让进程快速地访问到需要的文件，如何让进
程感觉到快速地把内容写入硬盘？&lt;/p&gt;

&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;

&lt;p&gt;简单地说，Page Cache就是对硬盘上的内容在物理内存中做一个缓存。
当进行一个I/O操作，比如read()系统调用时，内核首先检查数据是否已经存在于页高速
缓存中了。&lt;/p&gt;

&lt;p&gt;Page Cache中每个页所包含的数据肯定属于某个文件。这个文件（或者更准确地说是文件
的索引节点）就成为页的所有者。&lt;/p&gt;

&lt;p&gt;硬盘中的数据以“块”为单位组织，“块”的大小往往小于页的大小，于是有可能
&lt;strong&gt;一个页中的内容来自与多个不同的不连续的磁盘块&lt;/strong&gt;。（事实上，一个页的大小通常是
4KB，但是多数文件系统中，块的大小都是512 bytes。）
所以不能用设备号和块号来识别它，而是通过页的所有者（代表了一个文件）和所有者数
据中的索引（通常是一个索引节点和在相应文件中的偏移量）来识别页高速缓存中的页。&lt;/p&gt;

&lt;h3 id=&quot;写缓存回写&quot;&gt;写缓存–回写&lt;/h3&gt;

&lt;p&gt;Linux采用称为“回写”的写缓存。程序执行写操作直接写到缓存中，后端存储不会立刻直接
更新，而是将页高速缓存中被写入的页面标记成“脏”，并且被加入到脏页链表中。然后由
一个进程周期性将脏页链表中的页写回到硬盘，从而让硬盘中的数据和内存中最终一致。
最后再清理“脏”页标识。&lt;/p&gt;

&lt;h3 id=&quot;缓存回收&quot;&gt;缓存回收&lt;/h3&gt;

&lt;p&gt;当物理内存空间紧张时，内核需要把已经缓存着的内容选择一部分清除。内核首先会选择
干净的（不脏的）页面进行替换。当没有足够的干净页面时，内核就通过所谓预测算法来
会找出那些以后最不可能使用的页面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LRU算法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们先了解一下缓存中的LRU算法，或者叫“最近最少使用算法。可以把LRU算法理解成一个
链表，每访问一个页就把该页加到链表的尾部，而清理总是选择链表头部的页来做。这种
方式有个问题：如果我们有一些只会访问一次的文件，按照LRU算法这些文件也会被缓存，
但显然这些文件不应该被缓存才对。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;双链策略和LRU/n算法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Linux使用的是一个修改过的LRU算法，叫做双链策略。内核维护了两个链表：活跃链表和
非活跃链表。处于活跃链表上的内容被认为是”热“的且不会被换出，而在非活跃链表上的
页面则是可以被换出的。在活跃链表中的页面必须在其被访问时就处于非活跃链表中。两
个链表都被“伪LRU”规则维护：页面从尾部加入，从头部移除。两个链表需要维持平衡——
如果活跃链表变得过多而超过了非活跃链表，那么活跃链表的头页面将被重新移到非活跃
链表中以便能再被回收。这种双链表的方式也称为LRU/2。更普遍的方式是n个链表，称为
LRU/n。&lt;/p&gt;

&lt;p&gt;缓存中的页来自对文件的读写，包括普通文件，块设备文件和内存映射文件。&lt;/p&gt;

&lt;h2 id=&quot;数据结构&quot;&gt;数据结构&lt;/h2&gt;

&lt;h3 id=&quot;address_space对象&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address_space&lt;/code&gt;对象&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address_space&lt;/code&gt;结构是虚拟地址VMA结构体&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_area_struct&lt;/code&gt;的物理地址对等体。但一个
文件可以被10个&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_area_struct&lt;/code&gt;标识（比如5个进程，每个调用mmap()映射它两次），这
个文件只能有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;address_space&lt;/code&gt;，也就是文件可以有多个虚拟地址，但只能在物理内存
有一份。该结构定义在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;linux/fs.h&amp;gt;&lt;/code&gt;中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct address_space {
    struct inode            *host;              /* owner: inode, block_device */
    struct radix_tree_root  page_tree;          /* radix tree of all pages */
    spinlock_t              tree_lock;          /* and lock protecting it */
    unsigned int            i_mmap_writable;    /* count VM_SHARED mappings */
    struct prio_tree_root   i_mmap;             /* tree of private and shared mappings */
    struct list_head        i_mmap_nonlinear;   /* list VM_NONLINEAR mappings */
    struct mutex            i_mmap_mutex;       /* protect tree, count, list */
    /* Protected by tree_lock together with the radix tree */
    unsigned long           nrpages;            /* number of total pages */
    pgoff_t                 writeback_index;    /* writeback starts here */
    const struct address_space_operations *a_ops;   /* methods */
    unsigned long           flags;              /* error bits/gfp mask */
    struct backing_dev_info *backing_dev_info;  /* device readahead, etc */
    spinlock_t              private_lock;       /* for use by the address_space */
    struct list_head        private_list;       /* private address_space list */
    struct address_space    *assoc_mapping;     /*  */
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;每个&lt;a href=&quot;2013-11-07-mm_03_page_frame_manage.md&quot;&gt;页描述符（struct page）&lt;/a&gt;中都有两个字段：
“mapping”和”index”，mapping 字段指向了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;address_space&lt;/code&gt;结构，该结构对应的索引
节点所对应的文件中的某段内容，正是这个page上的内容（或者说应该是这个page上的内
容）。具体是那段内容就由&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;参数之指出，它以页大小作为单位，指出了该部分内容
的偏移量。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;page_tree&lt;/code&gt;表示了一个由拥有者（文件的inode）的所有页组成的基树（radix tree）的
根。通过这颗树，内核就可以快速搜索，看所需要的页是否在页高速缓存中。&lt;/p&gt;

&lt;p&gt;内核在页高速缓存中查找页时，正是用的这两个参数。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;i_mmap&lt;/code&gt;是一个优先搜索树，可以理解为内核通过这颗树把这个&lt;code class=&quot;highlighter-rouge&quot;&gt;address_space&lt;/code&gt;中的所有
映射组织起来，包括共享映射和似有映射（下面会讲到）。也就是说，这颗树由所有映射
到这个&lt;code class=&quot;highlighter-rouge&quot;&gt;address_space&lt;/code&gt;的VMA组成。&lt;code class=&quot;highlighter-rouge&quot;&gt;i_mmap&lt;/code&gt;表示的树– “Radix tree”是一个二叉树，只
要指定了文件偏移量，就可以在树中迅速找到需要的映射。这颗树的主要作用是“反向映射
”，这是为了快速标识共享一页的所有进程，这主要用在页框回收过程（之后会讲到）。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nrpages&lt;/code&gt;表示一共有多少个page在其中。&lt;/p&gt;

&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;address_struct&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;不为NULL，表示它与一个 inode 关联。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a_ops&lt;/code&gt;指向一个操作函数表，和VFS类似，函数表用&lt;code class=&quot;highlighter-rouge&quot;&gt;address_space_operations&lt;/code&gt;
结构体表示。其中最主要的几个功能是：读/写页，标记页为脏，释放页，直接IO操作等。&lt;/p&gt;

&lt;p&gt;每种FS都有自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;address_space_operations&lt;/code&gt;，描述自己如何与页高速缓存交互。&lt;/p&gt;

&lt;p&gt;读取一个页面包含下面这些操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先内核使用&lt;code class=&quot;highlighter-rouge&quot;&gt;find_get_page()&lt;/code&gt;试图在页高速缓存中找到需要的数据（使用
Radix Tree 搜索）:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;page = find_get_page(mapping, index)
/* mapping 指定 address_space, index以页为单位指定文件中的位置 */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果没有搜索到，&lt;code class=&quot;highlighter-rouge&quot;&gt;find_get_page()&lt;/code&gt;返回NULL，内核将分配一个新页面，然后将之前
搜索的页加入到页高速缓存中：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;page = page_cache_alloc_cold(mapping);
add_to_page_cache_lru(page, mapping, index, GFP_KERNEL)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后,需要的数据从磁盘被读入，再被加入页告诉缓存，然后返回给用户：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mapping-&amp;gt;a_ops-&amp;gt;readpage(file, page)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;写入&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于文件映射来说，当页被修改了，仅需要标记页面为脏：&lt;code class=&quot;highlighter-rouge&quot;&gt;SetPageDirty(page)&lt;/code&gt;即可，
内核晚些时候会通过&lt;code class=&quot;highlighter-rouge&quot;&gt;writepage()&lt;/code&gt;方法把页写出。&lt;/p&gt;

&lt;p&gt;对于特定文件，一般情况下，1. 页高速缓存中搜索需要的页，如果没找到，那么内核
就在高速缓存中新分配一空闲项；2. 然后内核创建一个写请求；3. 数据被从用户空间
拷贝到了内核缓冲；4. 数据被写入磁盘。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;flusher线程和pdflush线程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在以下3中情况发生时，脏页被写回磁盘：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当空闲内存低于特定的一个阈值时&lt;/li&gt;
  &lt;li&gt;当脏页在内存中驻留时间超过一个特定的阈值时&lt;/li&gt;
  &lt;li&gt;当用户进程调用sync()和fsync()系统调用时&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回写的阈值和一些参数可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/sys/vm&lt;/code&gt;中做设置。&lt;/p&gt;

&lt;p&gt;在2.6.32之前的版本，回写操作是由 pdflush(page dirty flush) 完成的。pdflush线程
的数目是动态的，目的在于，由于磁盘读写速度很慢，对于多个磁盘的情况，我们不希望
线程卡在某个拥塞的磁盘上。&lt;/p&gt;

&lt;p&gt;在2.6.32之后，内核使用了flusher线程代替pdflush，flusher线程和具体块设备关联，
相当于一个磁盘一个flusher线程，简单有效。&lt;/p&gt;

&lt;h2 id=&quot;例子&quot;&gt;例子&lt;/h2&gt;

&lt;p&gt;借用&lt;a href=&quot;http://duartes.org/gustavo/blog/post/page-cache-the-affair-between-memory-and-files&quot;&gt;Page Cache, the Affair Between Memory and Files&lt;/a&gt;
中的一个例子：程序叫 render ，它打开文件 scene.dat，读取512字节的数据，这些数据
会存放在它的虚拟内存空间中的Heap段。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/readFromPageCache.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中带标号的表示物理内存中的一个页，根据&lt;code class=&quot;highlighter-rouge&quot;&gt;address_space&lt;/code&gt;结构的分析我们知道，通过
文件和偏移（以页为单位），如果已经缓存的话，可以在page cache中找到这页内容。&lt;/p&gt;

&lt;p&gt;经过上图的过程，也就是首先内核读取文件的一部分到page cache，然后从page cache中
拷贝到用户空间的匿名VAM即Heap，可以看到，经过一次&lt;code class=&quot;highlighter-rouge&quot;&gt;read()&lt;/code&gt;调用，这部分内容事实
上在物理内存中存了两份：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/nonMappedFileRead.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;the-thing-king&quot;&gt;The Thing King&lt;/h1&gt;

&lt;p&gt;关于这一切是如何工作的，有一篇很有趣的文章&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/the-thing-king&quot;&gt;The Thing King&lt;/a&gt;，作者是写&lt;a href=&quot;http://book.douban.com/subject/1784687/&quot;&gt;Expert C Programming&lt;/a&gt;的 Peter van der Linden 。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/6097773/&quot;&gt;Linux内核设计与实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://oss.org.cn/kernel-book/ch06/6.3.1.htm&quot;&gt;深入分析Linux内核源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/2287506/&quot;&gt;深入理解Linux内核&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.win.tue.nl/~aeb/linux/lk/lk.html&quot;&gt;The Linux Kernel&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory&quot;&gt;Anatomy of a Program in Memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation&quot;&gt;Memory Translation and Segmentation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory&quot;&gt;How The Kernel Manages Your Memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/category/linux&quot;&gt;Page Cache, the Affair Between Memory and Files&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/the-thing-king&quot;&gt;The Thing King&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection&quot;&gt;CPU Rings, Privilege, and Protection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 17 Feb 2020 21:09:09 +0800</pubDate>
        <link>http://gaopenghigh.github.io/2020/02/17/2013-11-10-mm_07_page_cache.html</link>
        <guid isPermaLink="true">http://gaopenghigh.github.io/2020/02/17/2013-11-10-mm_07_page_cache.html</guid>
        
        
      </item>
    
      <item>
        <title></title>
        <description>&lt;h1 id=&quot;linux-内存管理6-进程地址空间的管理&quot;&gt;Linux 内存管理(6): 进程地址空间的管理&lt;/h1&gt;

&lt;p&gt;所谓的“进程地址空间（address space），就是进程可以使用的全部的线性地址。&lt;/p&gt;

&lt;p&gt;在内核中的函数以简单的方式获得内存，可以直接以页框为单位获取一段内存，也可以用
kmalloc或者vmalloc以字节为单位获取连续的或不连续的内存。由于内核是操作系统中最
高优先级的部分，所以被内存的请求会被马上响应并且真的分配出来。另外由于内核信任
自己，所以内核函数不必插入对编程错误的任何保护措施。&lt;/p&gt;

&lt;p&gt;但给用户态的进程分配内存时情况很不相同。&lt;/p&gt;

&lt;p&gt;首先，进程对动态内存的请求被认为是不紧迫的。当进程的可执行文件被装入时，
进程并不一定立即对所有的代码进行访问，当进程调用malloc()时，其申请的内存并不
一定很快会被访问。另外，用户进程是不可信任的，内核需要随时准备捕获用户态进程所
引起的寻址错误。&lt;/p&gt;

&lt;p&gt;所以，内核会尽量“推迟”对用户态进程的内存分配。当用户态进程请求动态内存时，并
没有真正获得页框，而仅仅获得了对一个新的线性地址区间（即所谓的VMA）的使用权，
同时这一线性地址区间就成为进程地址空间的一部分。&lt;/p&gt;

&lt;h2 id=&quot;内存描述符&quot;&gt;内存描述符&lt;/h2&gt;

&lt;p&gt;内核使用内存描述符结构体(&lt;code class=&quot;highlighter-rouge&quot;&gt;struct mm_struct&lt;/code&gt;)表示进程的地址空间，该结构包含了和
进程地址空间有关的全部信息，包括计数器、包含的内存区域、页全局目录、各个段的地
址等等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/mm_struct.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在进程的&lt;code class=&quot;highlighter-rouge&quot;&gt;task_struct&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;mm&lt;/code&gt;域就指向&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;结构，结构体中需要重点关注的字
段如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct mm_struct {
    ...
    struct vm_area_struct   *mmap;          /* VMA链表 */
    struct rb_root          mm_rb;          /* VMA形成的红黑树 */
    struct vm_area_struct   *mmap_cache;    /* 最近使用的内存区域 */
    pgd_t                   *pgd;           /* 页全局目录 */
    atomic_t                mm_users;       /* 使用该地址空间的用户数 */
    atomic_t                mm_count;       /* 主使用计数器 */
    int                     map_count;      /* 内存区域的个数 */
    struct list_head        mmlist;         /* 所有mm_struct形成的链表 */
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_users&lt;/code&gt;域记录正在使用改地址的进程数目。事实上使用同一个地址空间的进程就是线
程。&lt;/p&gt;

&lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_count&lt;/code&gt;为0时，表示没有任何指向该结构体的引用了，该结构体会被撤销。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mmap&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_rb&lt;/code&gt;两个结构体表述的都是该地址空间中所有的“内存区域”（内存区域下一小
节讨论），只不过前者是以链表的形式存放，后者是以红黑树的形式存放。链表方便遍历
，红黑树方便搜索。&lt;/p&gt;

&lt;p&gt;所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;通过自身的&lt;code class=&quot;highlighter-rouge&quot;&gt;mmlist&lt;/code&gt;域链接在一个双向链表中，该链表的首元素是
&lt;code class=&quot;highlighter-rouge&quot;&gt;init_mm&lt;/code&gt;内存描述符，它代表init进程的地址空间。&lt;/p&gt;

&lt;p&gt;进程fork时，子进程中的&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;结构体实际是通过文件&lt;code class=&quot;highlighter-rouge&quot;&gt;kenel/fork.c&lt;/code&gt;中的
&lt;code class=&quot;highlighter-rouge&quot;&gt;allocate_mm()&lt;/code&gt;宏从 mm cachep slab 缓存中分配的。通常每个进程都有唯一的
&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;，即唯一的地址空间。如果在调用clone()时设置&lt;code class=&quot;highlighter-rouge&quot;&gt;CLONE_VM&lt;/code&gt;标志，那么父
进程和子进程就共享地址空间，子进程的&lt;code class=&quot;highlighter-rouge&quot;&gt;task_struct&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;mm&lt;/code&gt;就直接指向父进程的
&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;，这样的进程就是线程。&lt;/p&gt;

&lt;h3 id=&quot;mm_struct-和内核线程&quot;&gt;mm_struct 和内核线程&lt;/h3&gt;

&lt;p&gt;内核线程没有进程地址空间，也没有相关的内存描述符。所以内核线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;task_struct&lt;/code&gt;
中的 mm 域为NULL。事实上，这也正是内核线程的真实含义——没有用户上下文。&lt;/p&gt;

&lt;p&gt;但尽管内核线程不需要使用进程地址空间，但即使访问内核内存，也需要使用一些数据，
比如页表，而这些数据一般是放在&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;中的。对此，Linux的方案是内核线程直接
使用上一个进程的&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;当一个内核线程被调度时，内核发现它的mm域为NULL，就会保留前一个进程的地址空间，
随后内核更新内核线程对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;task_struct&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;active_mm&lt;/code&gt;域，使其指向前一个进程的
&lt;code class=&quot;highlighter-rouge&quot;&gt;task_struct&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;虚拟内存区域vma&quot;&gt;虚拟内存区域(VMA)&lt;/h2&gt;

&lt;h3 id=&quot;vma结构&quot;&gt;VMA结构&lt;/h3&gt;

&lt;p&gt;虚拟内存区域（virtual memoryAreas，VMAs）由&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_area_struct&lt;/code&gt;结构体描述，它描述了
指定地址空间内连续区间上的一个独立内存范围。内核将每个VMA作为一个单独的内存对象
管理，每个VMA都拥有一致的属性，比如访问权限等，相应的操作也都一致。&lt;/p&gt;

&lt;p&gt;该结构体定义在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;linux/mm_types.h&amp;gt;&lt;/code&gt;中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct vm_area_struct {
    struct mm_struct * vm_mm;   /* 关联的mm_struct. */
    unsigned long vm_start;     /* VMA首地址 */
    unsigned long vm_end;       /* VMA尾地址 */
    struct vm_area_struct *vm_next, *vm_prev; /* VMA组成一个链表 */
    pgprot_t vm_page_prot;      /* Access permissions of this VMA. */
    unsigned long vm_flags;     /* 标志 */
    struct rb_node vm_rb;       /* 连接到红黑树 */

    union {
        struct {
            struct list_head list;
            void *parent;   /* aligns with prio_tree_node parent */
            struct vm_area_struct *head;
        } vm_set;
        struct raw_prio_tree_node prio_tree_node;
    } shared;

    struct list_head anon_vma_chain;
    struct anon_vma *anon_vma;
    const struct vm_operations_struct *vm_ops;
    unsigned long vm_pgoff;
    struct file * vm_file;      /* 所映射的文件 (can be NULL). */
    void * vm_private_data;     /* 私有数据 */
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结构体中的&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_mm&lt;/code&gt;指向相关的&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;结构体，&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_start&lt;/code&gt;表示VMA的首地址、
&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_end&lt;/code&gt;表示VMA的尾地址。&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_flags&lt;/code&gt;表示VMA的标志。&lt;/p&gt;

&lt;p&gt;几个常用的标志是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VM_READ&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;VM_WRITE&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;VM_EXEC&lt;/code&gt;标志了VMA中页面的读、写和执行权限。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VM_SHARED&lt;/code&gt;指明了内存区域包含的映射是否可以在多进程间共享，如果该标志被设置
，则成为共享映射，如果没有被设置，而仅仅只有一个进程可以使用该映射的内容，
则叫做私有映射。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VM_IO&lt;/code&gt;标志内存区域中包含对设备I/O空间的映射。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VM_SEQ_READ&lt;/code&gt;标志暗示应用程序对映射内容执行有序的读操作，这样内核可以有选择
地执行预读文件。&lt;code class=&quot;highlighter-rouge&quot;&gt;VM_RAND_READ&lt;/code&gt;意义正相反。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_file&lt;/code&gt;表示映射的文件，一个没有映射任何文件的VMA被称作是&lt;strong&gt;匿名&lt;/strong&gt;的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;vma操作&quot;&gt;VMA操作&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_area_struct&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_ops&lt;/code&gt;域指向VMA相关的操作函数表（和VFS的方式类似）。&lt;/p&gt;

&lt;p&gt;操作函数表由&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_operations_struct&lt;/code&gt;表示，一个简化版（去掉NUMA相关的内容）的
&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_operations_struct&lt;/code&gt;如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct vm_operations_struct {
    void (*open)(struct vm_area_struct * area);
    void (*close)(struct vm_area_struct * area);
    int (*fault)(struct vm_area_struct *vma, struct vm_fault *vmf);
    int (*page_mkwrite)(struct vm_area_struct *vma, struct vm_fault *vmf);
    int (*access)(struct vm_area_struct *vma, unsigned long addr,
              void *buf, int len, int write);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;进程所拥有的VMA从来不重叠，并且内核尽力把新分配的VMA与紧邻的现有VMA进行合并：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/add_or_delete_vma.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;mm_struct-和-vm_area_struct-的组织&quot;&gt;mm_struct 和 vm_area_struct 的组织&lt;/h2&gt;

&lt;p&gt;前面说到，&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_area_struct&lt;/code&gt;同时以链表形式和红黑树形式存在与&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;中 。&lt;/p&gt;

&lt;p&gt;对于链表结构，每一个&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_area_struct&lt;/code&gt;都通过自身的&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_next&lt;/code&gt;域被连入链表，所有的区
域按照地址增长的方向排序。当我们查看&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/pid_of_process/maps&lt;/code&gt;时，内核就通过
链表遍历所有的VMA并打印出来。&lt;/p&gt;

&lt;p&gt;对于红黑树，&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_rb&lt;/code&gt;就指向红黑树的
根节点，每个VMA通过&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_rb&lt;/code&gt;连接到树中。红黑树的搜索、删除和插入操作的复杂度都为
O(log(n))。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;task_struct&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_area_struct&lt;/code&gt;的组织实例如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/memoryDescriptorAndMemoryAreas.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;vma的工作方式一个例子&quot;&gt;VMA的工作方式+一个例子&lt;/h2&gt;

&lt;p&gt;VMA作用在内核和进程之间。程序发出一个请求（请求一块内存或者请求映射一个文件），
内核回答说“OK“，但并没有真的找一块物理内存给程序，而只是修改或者创建VMA，让
进程以为已经得到想要的内存了。当进程真的用到了更新过或是新申请的VMA时，发现
VMA中的页没有指向一个有效的页表项(PTE)，这就会引发一个&lt;strong&gt;页错误(page fault)&lt;/strong&gt;，
这时内核才会去去老老实实地做些事情，分配一块物理内存或者其他事情，然后修改页表
，使VMA中的页映射到“正确”的页表项（PTE）。&lt;/p&gt;

&lt;p&gt;一个例子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/heapAllocation.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;进程通过&lt;code class=&quot;highlighter-rouge&quot;&gt;brk()&lt;/code&gt;系统调用申请一块内存，这块内存应该在heap的VMA上。&lt;/li&gt;
  &lt;li&gt;内核更新VMA，系统调用返回“OK”，此时并没有物理内存页表被真的分配出来。&lt;/li&gt;
  &lt;li&gt;进程试图使用这块内存，引发处理器的page fault，函数&lt;code class=&quot;highlighter-rouge&quot;&gt;do_page_fault()&lt;/code&gt;被调用
。该函数通过&lt;code class=&quot;highlighter-rouge&quot;&gt;find_vma()&lt;/code&gt;搜索包含了这部分地址的VMA，如果没有找到，则触发
“段错误(Segmentation Fault)”。&lt;/li&gt;
  &lt;li&gt;找到了对应的VMA，在对VMA做一些权限方面的检查后，内核试图通过页表找到物理内
存地址。当发现并没有一个PTE为为这个虚拟内存页服务，内核知道这部分虚拟内存从
来没有被映射过，并且这个VMA是匿名的，于是内核调用&lt;code class=&quot;highlighter-rouge&quot;&gt;do_anonymous_pages()&lt;/code&gt;，从
物理内存中分配一个页框，然后创建一个PTE来把出现fault的虚拟页map到刚分配到的
物理页框上。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于交换出去的页框，它的PTE中”P”标志为0，代表它当前不在物理内存中，但它的地址又
不为空，事实上，它存的是交换地址，通过一个&lt;strong&gt;“缺页异常”&lt;/strong&gt;，内核从硬盘上读取这部分
内容并且加载到内存中。&lt;/p&gt;

&lt;h3 id=&quot;缺页异常&quot;&gt;缺页异常&lt;/h3&gt;

&lt;p&gt;当程序访问一个页，这个页在进程的地址空间中存在，但是在没有加载到物理内存中时，
就会由硬件引发一个 trap, 这就叫做“缺页异常（Page Fault）”。操作系统一般会通过两
种方式处理缺页异常，一是使请求的页可访问，二是当请求访问的页不合法时，就终止
程序。也就是说，缺页异常由处理器的内存管理单元(memory management unit, mmu)触发
，由操作系统的异常处理程序来处理。&lt;/p&gt;

&lt;p&gt;缺页异常分为3种，参考
&lt;a href=&quot;http://en.wikipedia.org/wiki/Page_fault&quot;&gt;Page fault&lt;/a&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Major, major page fault 发生时，需要从硬盘读取数据。&lt;/li&gt;
  &lt;li&gt;Minor, minor page fault 发生时，所需要的内容已经在内存里了（可能是有其他
进程加载进来的），但是没有被mmu标记，所以只需要修改相关的内容指向正确的位置
就行。&lt;/li&gt;
  &lt;li&gt;Invalid, 所请求的地址不在进程地址空间内，就触发一个invalid page fault。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺页异常处理程序的总体方案如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/page_fault_policy.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;具体的处理流程大致如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/page_fault_policy_detail.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;vma的操作&quot;&gt;VMA的操作&lt;/h3&gt;

&lt;h4 id=&quot;find_vma&quot;&gt;find_vma()&lt;/h4&gt;

&lt;p&gt;内核通过&lt;code class=&quot;highlighter-rouge&quot;&gt;find_vma()&lt;/code&gt;来找到一个给定的内存地址属于哪一个内存区域。
该文件定义在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mm/mmap.c&amp;gt;&lt;/code&gt;中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct vm_area_struct * find_vma(struct mm_struct *mm, unsigned long addr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;搜索通过&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;中的红黑树进行。它会返回第一个&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_end&lt;/code&gt;大于addr的VMA。
返回的结果会缓存在&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mmap_cache&lt;/code&gt;中。&lt;/p&gt;

&lt;h4 id=&quot;find_vma_prev&quot;&gt;find_vma_prev()&lt;/h4&gt;

&lt;p&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;find_vma()&lt;/code&gt;类似，只是返回的是第一个小于addr的VMA。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct vm_area_struct * find_vma_prev(struct mm_struct *mm,
                                      unsigned long addr,
                                      struct vm_area_struct **pprev)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;find_vma_intersection&quot;&gt;find_vma_intersection()&lt;/h4&gt;

&lt;p&gt;返回第一个和指定地址区间相交的VMA。&lt;/p&gt;

&lt;h4 id=&quot;mmap和do_mmap&quot;&gt;mmap()和do_mmap()&lt;/h4&gt;

&lt;p&gt;内核使用&lt;code class=&quot;highlighter-rouge&quot;&gt;do_mmap()&lt;/code&gt;函数创建一个新的线性地址区间。事实上，如果创建的地址区间和
一个已经存在的地址区间相邻，并且它们具有相同的访问权限的话，两个区间将合并为一
个。该函数定义在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;linux/mm.h&amp;gt;&lt;/code&gt;中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unsigned long do_mmap(struct file *file, unsigned long addr,
                      unsigned long len, unsigned long prot,
                      unsigned long flag, unsigned long offset)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该函数映射由 file 指定的文件，偏移量为 offset ，长度为 len 。如果 file 为 NULL
并且 offset 也为0，则代表这次映射为&lt;strong&gt;匿名映射&lt;/strong&gt;，否则叫做&lt;strong&gt;文件映射&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mmap&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;do_mmap()&lt;/code&gt;类似，只不过适用于用户空间。&lt;/p&gt;

&lt;h2 id=&quot;内核栈和中断栈&quot;&gt;内核栈和中断栈&lt;/h2&gt;

&lt;p&gt;在每一个进程的生命周期中，必然会通过到系统调用陷入内核。在执行系统调用陷入内核
之后，这些内核代码所使用的栈并不是原先用户空间中的栈，而是一个内核空间的栈，
称作进程的“内核栈”。&lt;/p&gt;

&lt;p&gt;内核为每个进程分配了一个内核栈，事实上每个进程的内核栈和它的&lt;code class=&quot;highlighter-rouge&quot;&gt;thread_info&lt;/code&gt;结构在
一起。&lt;/p&gt;

&lt;p&gt;每个进程的内核栈大小既依赖体系结构，也与编译时的选项有关。历史上每个进程都有两
页大小内核栈（对于32位系统是4x2=8K，64位系统是8x2=16K大小）。&lt;/p&gt;

&lt;p&gt;随着机器运行时间的增加，寻找两个未分配的、连续的页变得越来越困难，物理内存渐渐
变为碎片，因此给一个新进程分配虚拟内存的压力也在增大。所以后来内核多了一个编译
选项，可以选择内核栈为1页。现在，对于32位系统，默认内核栈为2页，可以选择设置
为一页。而对于64位系统，则固定为两页(8K)。&lt;/p&gt;

&lt;p&gt;如果内核栈为2页，中断处理程序也会使用它们中断的进程的内核栈。事实上这个内核栈
会被用于所有类型的内核控制路径：异常、中断（硬件中断）、和可延迟函数（软中断和
tasklet）。&lt;/p&gt;

&lt;p&gt;如果编译时指定定内核栈大小为1页，则: 1. 每个进程都会有一个独立的异常栈，用于
异常处理，这个栈包含在每个进程的&lt;code class=&quot;highlighter-rouge&quot;&gt;thread_union&lt;/code&gt;结构中。2. 每个CPU有一个硬中断
请求栈，大小为一页，用于处理中断。3. 每个CPU都有一个软中断请求栈，大小为一页，
用于处理可延迟函数。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/6097773/&quot;&gt;Linux内核设计与实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://oss.org.cn/kernel-book/ch06/6.3.1.htm&quot;&gt;深入分析Linux内核源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/2287506/&quot;&gt;深入理解Linux内核&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.win.tue.nl/~aeb/linux/lk/lk.html&quot;&gt;The Linux Kernel&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory&quot;&gt;Anatomy of a Program in Memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation&quot;&gt;Memory Translation and Segmentation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory&quot;&gt;How The Kernel Manages Your Memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/category/linux&quot;&gt;Page Cache, the Affair Between Memory and Files&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/the-thing-king&quot;&gt;The Thing King&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection&quot;&gt;CPU Rings, Privilege, and Protection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 17 Feb 2020 21:09:09 +0800</pubDate>
        <link>http://gaopenghigh.github.io/2020/02/17/2013-11-09-mm_06_process_address_space.html</link>
        <guid isPermaLink="true">http://gaopenghigh.github.io/2020/02/17/2013-11-09-mm_06_process_address_space.html</guid>
        
        
      </item>
    
      <item>
        <title></title>
        <description>&lt;h1 id=&quot;linux-内存管理5-进程地址空间的结构&quot;&gt;Linux 内存管理(5): 进程地址空间的结构&lt;/h1&gt;

&lt;p&gt;以下内容严重参考了
&lt;a href=&quot;http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory&quot;&gt;Anatomy of a Program in Memory&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;内核空间和用户空间&quot;&gt;内核空间和用户空间&lt;/h2&gt;

&lt;p&gt;每个进程运行在自己的内存沙盒中，这个沙盒就是所谓的进程的地址空间
（address space）。线性内存内存和物理内存主要通过“页表”进行转换，每个进程都有自
己的页表。由于内核必须随时随地都能运行，所以在虚拟地址空间中都有固定的一部分是
属于内核的。叫做内核空间（Kernel Space），剩下的部分叫做用户空间
(User Mode Space)。&lt;/p&gt;

&lt;p&gt;对于32位系统来说，整个虚拟内存空间的大小是4G，其中内核空间占用了1G，用户空间
使用了3G。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; __________________
| Kernel Space(1G) | 0xffffffff
|__________________| 0xc0000000
|                  |
| User Mode Space  |
|       (3G)       |
|                  |
|                  |
|__________________| 0x00000000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;进程切换的过程中，内核空间不变，只不过使用的用户空间是各个进程自己的地址空间。
如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/virtualMemoryInProcessSwitch.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，蓝色部分表示的虚拟内存已经映射到了物理内存中，白色部分没有映射。&lt;/p&gt;

&lt;h2 id=&quot;进程地址空间的结构&quot;&gt;进程地址空间的结构&lt;/h2&gt;

&lt;p&gt;上图中，不同的带区代表了不同的段。这些段主要有：
Stack，Heap，Memory Mapping Segment，BSS Segment，Data Segment，Text Segment。&lt;/p&gt;

&lt;p&gt;如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/linuxFlexibleAddressSpaceLayout.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;简单介绍如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stack&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;进程地址空间的最顶端是栈。
栈存放进程临时创建的局部变量，也就是在’{}’之间的变量（但不包括static
声明的变量，Static声明的变量存放在Data Segment中），
另外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，
函数的返回值也会被存放回栈中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Memory Mapping Segment&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个段在栈的底下，存放文件映射（包括动态库）和匿名映射的数据。
进程可以通过 mmap() 系统调用进行文件内存映射。&lt;/p&gt;

&lt;p&gt;有一种映射没有对应到任何文件。叫做匿名映射(TODO：给出参考链接)。
在C标准库中，如果malloc一块大于某个大小的内存，C库就会创建一个匿名映射。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Heap&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在Memory Mapping Segment底部就是堆(Heap)。
堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。
当进程调用malloc等函数分配内存时，新分配的内存就通过 brk() 系统调用被动态添加到
堆上（堆被扩张），当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩
减）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BSS Segment&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;包含了程序中未初始化的全局变量，在内存中bss段全部置零。该段是匿名(anonymous)的
，它没有映射到任何文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Data Segment(数据段)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该段包含了在代码中初始化的变量。这个区域不是匿名(anonymous)的。它映射到了程序二
进制文件中包含了初始化静态变量的那个部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Text Segment(代码段)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该段存放可执行文件的操作指令，也就是说这个段是可执行文件在内存中的镜像。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;段之间的随机偏移&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从图中可以看到，段之间会有一个随机的偏移（offset），这是因为几乎所有的进程都拥
有一样的内存结构，如果让进程获取到各个段的真实地址，就会有安全上的风险。&lt;/p&gt;

&lt;p&gt;可以参考&lt;a href=&quot;http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory&quot;&gt;Anatomy of a Program in Memory&lt;/a&gt;
中所说的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When computing was happy and safe and cuddly, the starting virtual addresses
for the segments shown above were exactly the same for nearly every process in
a machine. This made it easy to exploit security vulnerabilities remotely. An
exploit often needs to reference absolute memory locations: an address on the
stack, the address for a library function, etc. Remote attackers must choose
this location blindly, counting on the fact that address spaces are all the
same. When they are, people get pwned. Thus address space randomization has
become popular. Linux randomizes the stack, memory mapping segment, and heap
by adding offsets to their starting addresses. Unfortunately the 32-bit
address space is pretty tight, leaving little room for randomization and
hampering its effectiveness.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;一个内存结构的例子&quot;&gt;一个内存结构的例子&lt;/h3&gt;

&lt;p&gt;使用 pmap 工具或者查看 ‘/proc/[pid]/maps’ 就可以看到一个进程的内存结构。&lt;/p&gt;

&lt;p&gt;示例程序(a.c)如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;

int main() {
    int i;
    int fd;
    int *map;
    fd = open(&quot;a.c&quot;, O_RDONLY);
    map = mmap(0, 10, PROT_READ, MAP_SHARED, fd, 0);
    scanf(&quot;%d&quot;, &amp;amp;i);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;程序中打开了一个文件并且mmap了一部分内容到内存中。使用 pmap 查看该进程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pmap -d 12340
12340:   ./a.out
Address           Kbytes Mode  Offset           Device    Mapping
0000000000400000       4 r-x-- 0000000000000000 008:00003 a.out
0000000000600000       4 r---- 0000000000000000 008:00003 a.out
0000000000601000       4 rw--- 0000000000001000 008:00003 a.out
00007f3dd91c5000    1784 r-x-- 0000000000000000 008:00001 libc-2.17.so
00007f3dd9383000    2044 ----- 00000000001be000 008:00001 libc-2.17.so
00007f3dd9582000      16 r---- 00000000001bd000 008:00001 libc-2.17.so
00007f3dd9586000       8 rw--- 00000000001c1000 008:00001 libc-2.17.so
00007f3dd9588000      20 rw--- 0000000000000000 000:00000   [ anon ]
00007f3dd958d000     140 r-x-- 0000000000000000 008:00001 ld-2.17.so
00007f3dd9786000      12 rw--- 0000000000000000 000:00000   [ anon ]
00007f3dd97ab000       4 rw--- 0000000000000000 000:00000   [ anon ]
00007f3dd97ac000       4 r--s- 0000000000000000 008:00003 a.c
00007f3dd97ad000       8 rw--- 0000000000000000 000:00000   [ anon ]
00007f3dd97af000       4 r---- 0000000000022000 008:00001 ld-2.17.so
00007f3dd97b0000       8 rw--- 0000000000023000 008:00001 ld-2.17.so
00007fff7c355000     132 rw--- 0000000000000000 000:00000   [ stack ]
00007fff7c3fe000       8 r-x-- 0000000000000000 000:00000   [ anon ]
ffffffffff600000       4 r-x-- 0000000000000000 000:00000   [ anon ]
mapped: 4208K    writeable/private: 196K    shared: 4K
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到，进程使用了4208K的空间，但真正自己消耗的只有196K，其他都是被共享库什么
的占用了。查看’/proc/[pid]/maps’中的内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat /proc/12340/maps
00400000-00401000 r-xp 00000000 08:03 2364279                            /home/gp/tmp/a.out
00600000-00601000 r--p 00000000 08:03 2364279                            /home/gp/tmp/a.out
00601000-00602000 rw-p 00001000 08:03 2364279                            /home/gp/tmp/a.out
7f3dd91c5000-7f3dd9383000 r-xp 00000000 08:01 394355                     /lib/x86_64-linux-gnu/libc-2.17.so
7f3dd9383000-7f3dd9582000 ---p 001be000 08:01 394355                     /lib/x86_64-linux-gnu/libc-2.17.so
7f3dd9582000-7f3dd9586000 r--p 001bd000 08:01 394355                     /lib/x86_64-linux-gnu/libc-2.17.so
7f3dd9586000-7f3dd9588000 rw-p 001c1000 08:01 394355                     /lib/x86_64-linux-gnu/libc-2.17.so
7f3dd9588000-7f3dd958d000 rw-p 00000000 00:00 0
7f3dd958d000-7f3dd95b0000 r-xp 00000000 08:01 394329                     /lib/x86_64-linux-gnu/ld-2.17.so
7f3dd9786000-7f3dd9789000 rw-p 00000000 00:00 0
7f3dd97ab000-7f3dd97ac000 rw-p 00000000 00:00 0
7f3dd97ac000-7f3dd97ad000 r--s 00000000 08:03 2364727                    /home/gp/tmp/a.c
7f3dd97ad000-7f3dd97af000 rw-p 00000000 00:00 0
7f3dd97af000-7f3dd97b0000 r--p 00022000 08:01 394329                     /lib/x86_64-linux-gnu/ld-2.17.so
7f3dd97b0000-7f3dd97b2000 rw-p 00023000 08:01 394329                     /lib/x86_64-linux-gnu/ld-2.17.so
7fff7c355000-7fff7c376000 rw-p 00000000 00:00 0                          [stack]
7fff7c3fe000-7fff7c400000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到在改进程的地址空间中，地址从低到高，一开始分别是”Text Segment”，
“Data Segment” 和 “BSS Segment”，然后是libc，ld以及程序中做的 a.c 这个文件的映
射。接下来是进程的栈，在栈之后是 vdso 和 vsyscall。简单地说，vdso和vsyscall是
内核的一种机制，能让进程使用某些系统调用时（比如获取时间的系统调用）运行得更快
。具体可参考
&lt;a href=&quot;http://lwn.net/Articles/446528/&quot;&gt;On vsyscalls and the vDSO&lt;/a&gt;，
&lt;a href=&quot;http://blog.csdn.net/wlp600/article/details/6886162&quot;&gt;VDSO&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;TODO:上面的输出内容中，libc有一个VMA的Mode是&lt;code class=&quot;highlighter-rouge&quot;&gt;----&lt;/code&gt;不知道是什么意思？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;00007f3dd9383000    2044 ----- 00000000001be000 008:00001 libc-2.17.so
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/6097773/&quot;&gt;Linux内核设计与实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://oss.org.cn/kernel-book/ch06/6.3.1.htm&quot;&gt;深入分析Linux内核源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/2287506/&quot;&gt;深入理解Linux内核&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.win.tue.nl/~aeb/linux/lk/lk.html&quot;&gt;The Linux Kernel&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory&quot;&gt;Anatomy of a Program in Memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation&quot;&gt;Memory Translation and Segmentation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory&quot;&gt;How The Kernel Manages Your Memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/category/linux&quot;&gt;Page Cache, the Affair Between Memory and Files&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/the-thing-king&quot;&gt;The Thing King&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection&quot;&gt;CPU Rings, Privilege, and Protection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 17 Feb 2020 21:09:09 +0800</pubDate>
        <link>http://gaopenghigh.github.io/2020/02/17/2013-11-09-mm_05_process_memory.html</link>
        <guid isPermaLink="true">http://gaopenghigh.github.io/2020/02/17/2013-11-09-mm_05_process_memory.html</guid>
        
        
      </item>
    
      <item>
        <title></title>
        <description>&lt;h1 id=&quot;linux-内存管理4-以字节为单位的内存管理&quot;&gt;Linux 内存管理(4): 以字节为单位的内存管理&lt;/h1&gt;

&lt;p&gt;本节讨论以字节为单位的内存管理。&lt;/p&gt;

&lt;h2 id=&quot;kmalloc和vmalloc&quot;&gt;kmalloc()和vmalloc()&lt;/h2&gt;

&lt;h3 id=&quot;kmalloc&quot;&gt;kmalloc()&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kmalloc()&lt;/code&gt;和用户空间中的&lt;code class=&quot;highlighter-rouge&quot;&gt;malloc()&lt;/code&gt;类似，只不过多了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;flag&lt;/code&gt;参数。它可以获得以
字节为单位的一块内核内存。大多数内核分配都使用&lt;code class=&quot;highlighter-rouge&quot;&gt;kmalloc()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;声明在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;linux/slab.h&amp;gt;&lt;/code&gt;中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void * kmalloc(size_t size, gfp_t flags)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kmalloc()&lt;/code&gt;的另一端就是&lt;code class=&quot;highlighter-rouge&quot;&gt;kfree&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void kfree(const void *ptr)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;vmalloc&quot;&gt;vmalloc()&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vmalloc()&lt;/code&gt;类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;kmalloc()&lt;/code&gt;，只不过vmalloc()分配的线性地址是连续的，而物理地址
无须连续。这也是用户空间分配函数的工作方式，由malloc()返回的页在进程的线性地址
空间内是连续的，但并不保证它们在物理RAM中也是连续的。vmalloc()只确保页在线性地
址中是连续的，它通过分配非连续的物理内存块，再“修正”页表，把物理内存映射到线性
地址空间的连续区域中。这会有一些性能损耗，所以vmalloc()常用于分配大块的内存。&lt;/p&gt;

&lt;p&gt;相对应的释放函数为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void vfree(const void *addr)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;slab层&quot;&gt;slab层&lt;/h2&gt;

&lt;p&gt;分配和释放数据结构是内核中最普遍的操作之一，为了便于数据的频繁分配和回收，程序
员常常用到空闲链表，空闲链表提供可用的，已经分配好的数据结构块，需要是从链表中
取一个，用完后再放回链表。slab层就是类似这个空闲链表的角色。&lt;/p&gt;

&lt;p&gt;slab分配器扮演了通用数据结构缓存层的角色。它把不同的对象划分为所谓高速缓存组，
其中每个高速缓存组都存放不同类型的对象。比如一个高速缓存组用于存放进程描述符（
task_struct），另一个高速缓存存放索引节点对象（struct inode）。&lt;/p&gt;

&lt;p&gt;然后这些高速缓存又被划分为slab，slab由一个或多个物理上连续的页组成，每个高速
缓存可以由多个slab组成。slab中包含一些对象成员，而slab的状态可以为“满”，“部分满
”或者“空”。当内核的某一部分需要一个新的对象时，先从部分满的slab中进行分配，如果
没有部分满的slab，就从空的slab中分配。&lt;/p&gt;

&lt;h3 id=&quot;结构和使用&quot;&gt;结构和使用&lt;/h3&gt;

&lt;p&gt;每个高速缓存都使用&lt;code class=&quot;highlighter-rouge&quot;&gt;kmem_cache&lt;/code&gt;结构体表示，该结构体包含三个链表：&lt;code class=&quot;highlighter-rouge&quot;&gt;slabs_full&lt;/code&gt;，
&lt;code class=&quot;highlighter-rouge&quot;&gt;slabs_partial&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;slabs_empty&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;slab描述符&lt;code class=&quot;highlighter-rouge&quot;&gt;struct slab&lt;/code&gt;用来描述每个slab:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct slab {
    struct list_head    list;      /* 满、部分满或空的链表 */
    unsigned long       colouroff; /* slab 着色的偏移量 */
    void                *s_mem;    /* 在slab中的第一个对象 */
    unsigned int        inuse;     /* slab中已分配的对象数 */
    kmem_bufctl_t       free;      /* 第一个空闲对象(如果有的话) */
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;slab分配器使用&lt;code class=&quot;highlighter-rouge&quot;&gt;__get_free_pages()&lt;/code&gt;来创建新的slab。&lt;/p&gt;

&lt;p&gt;创建新的高速缓存：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct kmem_cache * kmem_cache_create(const char *name,
                                      size_t, size,
                                      size_t align,
                                      unsigned long flags,
                                      void (*ctor)(void *));
/*
 * name 表示高速缓存的名字
 * size 指每个元素的大小
 * align 指slab内第一个元素的偏移，一般为0
 * flags 用来控制高速缓存的行为
 * ctor 是高速缓存的构造函数，但Linux没有用到它
 */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从缓存中分配：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void * kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;释放一个对象，返还给原先的slab：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void kmem_cache_free(struct kmem_cache *cachep, void *objp)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/6097773/&quot;&gt;Linux内核设计与实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://oss.org.cn/kernel-book/ch06/6.3.1.htm&quot;&gt;深入分析Linux内核源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/2287506/&quot;&gt;深入理解Linux内核&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.win.tue.nl/~aeb/linux/lk/lk.html&quot;&gt;The Linux Kernel&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory&quot;&gt;Anatomy of a Program in Memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation&quot;&gt;Memory Translation and Segmentation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory&quot;&gt;How The Kernel Manages Your Memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/category/linux&quot;&gt;Page Cache, the Affair Between Memory and Files&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/the-thing-king&quot;&gt;The Thing King&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection&quot;&gt;CPU Rings, Privilege, and Protection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 17 Feb 2020 21:09:09 +0800</pubDate>
        <link>http://gaopenghigh.github.io/2020/02/17/2013-11-09-mm_04_memory_management_by_bytes.html</link>
        <guid isPermaLink="true">http://gaopenghigh.github.io/2020/02/17/2013-11-09-mm_04_memory_management_by_bytes.html</guid>
        
        
      </item>
    
      <item>
        <title></title>
        <description>&lt;h1 id=&quot;linux-内存管理3-页框的管理&quot;&gt;Linux 内存管理(3): 页框的管理&lt;/h1&gt;

&lt;h3 id=&quot;页描述符&quot;&gt;页描述符&lt;/h3&gt;

&lt;p&gt;内核必须记录每个页框当前的状态。
每个页框用一个&lt;code class=&quot;highlighter-rouge&quot;&gt;struct page&lt;/code&gt;结构表示，通过该结构，内核知道当前这部分内存是什么
状态，在用于什么。因为内核需要知道一个页是否空闲，如果页已经被分配，内核还需要
知道谁拥有这个页。拥有者可能是用户空间进程、动态分配的内核数据、静态内核代码或
者页高速缓存等。&lt;/p&gt;

&lt;p&gt;该结构又叫做“页描述符”，位于&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;linux/mm_types.h&amp;gt;&lt;/code&gt;中。
一个简化版的&lt;code class=&quot;highlighter-rouge&quot;&gt;struct page&lt;/code&gt;如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct page {
    unsigned long           flags;
    atomic_t                _count;
    atomic_t                _mapcount;
    unsigned long           private;
    struct address_space    *mapping;
    pgoff_t                 index;
    struct list_head        lru;
    void                    *virtual;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flag&lt;/code&gt;存放页的状态，包括是否为脏，是否被锁定在内存中等。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_count&lt;/code&gt;存放页的引用计数，-1表示这一页空闲，当前内核没有引用这一页，在新的
分配中就可以使用它。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;virtual&lt;/code&gt;表示页的线性地址。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mapping&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;两个字段用于在页高速缓存中找到这个页。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过很多的&lt;code class=&quot;highlighter-rouge&quot;&gt;struct page&lt;/code&gt;结构，内核就可以知道整个物理内存是什么状态。&lt;/p&gt;

&lt;h3 id=&quot;内存管理区&quot;&gt;内存管理区&lt;/h3&gt;

&lt;p&gt;基于硬件方面的限制，内核把每个内存节点的物理内存划分为3个区（zone）:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZONE_DMA&lt;/code&gt;，包含低于16MB的内存页框，区中的页用来执行DMA，即直接内存访问操作&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZONE_NORMAL&lt;/code&gt;，包含高于16MB且低于896MB的内存页框，此区内都是能正常映射的页&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ZONE_HGMEM&lt;/code&gt;，包含从896MB开始的内存页框，“高端内存”，其中的页不能被永久地映
射到内核地址空间。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于64位Intel体系，可以映射和处理64位的内存空间，所以没有ZONE_HIGHMEM区，所有内
存都在ZONE_DMA和ZONE_NORMAL区。&lt;/p&gt;

&lt;p&gt;当内核调用一个内存分配函数时，必须指明请求页框所在的区。&lt;/p&gt;

&lt;h3 id=&quot;获得和释放页框&quot;&gt;获得和释放页框&lt;/h3&gt;

&lt;p&gt;获得页框的最核心的函数是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct page * alloc_pages(gfp_t gfp_mask, unsigned int order)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该函数分配2^order个连续的物理页，并返回一个指针，指向第一个页的page结构体。&lt;/p&gt;

&lt;p&gt;下面的函数把给定的页框转换为线性地址：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void * page_address(struct page *page)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果不需要使用struct page，可以使用下面的方法直接得到线性地址：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gfp_mask&lt;/code&gt;标志指定了内核在分配内存时，需要遵守一定行为约束，并且从需要的区中分
配内存（比如ZONE_DMA区还是ZONE_HIHGMEM区）。“行为约束”包括分配器是否可以睡眠、
是否可以启动磁盘IO、是否应该使用高速缓存中快要淘汰出去的页等等。这些规则可以组
合成不同的类型。最主要的两个&lt;code class=&quot;highlighter-rouge&quot;&gt;gfp_mask&lt;/code&gt;类型是:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GFP_KERNEL&lt;/code&gt;：常规分配方式，可能会阻塞。这个标志在睡眠安全时用在进程上下文
代码中。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GFP_ATOMIC&lt;/code&gt;：用在中断处理程序、下半部、持有自选锁以及其他不能睡眠的地方。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用下面的函数释放页：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void __free_pages(struct page *page, unsigned int order)
void free_pages(unsigned long addr, unsigned int order)
void free_page(unsigned long addr)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于内核经常请求和释放单个页框，所以为了提高性能，每个内存管理区域（zone）定义
了一个“每CPU页框高速缓存”，其中包含一些预先分配的页框，它们被用于满足本地CPU发
出的单一内存请求。&lt;/p&gt;

&lt;h3 id=&quot;伙伴算法&quot;&gt;伙伴算法&lt;/h3&gt;

&lt;p&gt;内核使用&lt;strong&gt;“伙伴关系”&lt;/strong&gt;来管理物理内存页框，这样有利于分配出连续的内存页。参考
&lt;a href=&quot;http://en.wikipedia.org/wiki/Buddy_memory_allocation&quot;&gt;Buddy memory allocation&lt;/a&gt;
。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Linux的伙伴算法把所有的空闲页面分为10个块组，每组中块的大小是2的幂次方个页面，
例如，第0组中块的大小都为2^0 （1个页面），第1组中块的大小为都为2^1（2个页面），
第9组中块的大小都为2^9（512个页面）。也就是说，每一组中块的大小是相同的，且这同
样大小的块形成一个链表。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设要求分配的块其大小为128个页面（由多个页面组成的块我们就叫做页面块）。该算
法先在块大小为128个页面的链表中查找，看是否有这样一个空闲块。如果有，就直接分配
；如果没有，该算法会查找下一个更大的块，具体地说，就是在块大小为256个页面的链
表中查找一个空闲块。如果存在这样的空闲块，内核就把这256个页面分为两等份，一份分
配出去，另一份插入到块大小为128个页面的链表中。如果在块大小为256个页面的链表中
也没有找到空闲页块，就继续找更大的块，即512个页面的块。如果存在这样的块，内核就
从512个页面的块中分出128个页面满足请求，然后从384个页面中取出256个页面插入到块
大小为256个页面的链表中。然后把剩余的128个页面插入到块大小为128个页面的链表中。
如果512个页面的链表中还没有空闲块，该算法就放弃分配，并发出出错信号。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/6097773/&quot;&gt;Linux内核设计与实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://oss.org.cn/kernel-book/ch06/6.3.1.htm&quot;&gt;深入分析Linux内核源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/2287506/&quot;&gt;深入理解Linux内核&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.win.tue.nl/~aeb/linux/lk/lk.html&quot;&gt;The Linux Kernel&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory&quot;&gt;Anatomy of a Program in Memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation&quot;&gt;Memory Translation and Segmentation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory&quot;&gt;How The Kernel Manages Your Memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/category/linux&quot;&gt;Page Cache, the Affair Between Memory and Files&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/the-thing-king&quot;&gt;The Thing King&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection&quot;&gt;CPU Rings, Privilege, and Protection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 17 Feb 2020 21:09:09 +0800</pubDate>
        <link>http://gaopenghigh.github.io/2020/02/17/2013-11-07-mm_03_page_frame_manage.html</link>
        <guid isPermaLink="true">http://gaopenghigh.github.io/2020/02/17/2013-11-07-mm_03_page_frame_manage.html</guid>
        
        
      </item>
    
      <item>
        <title></title>
        <description>&lt;h1 id=&quot;linux-内存管理2-分页&quot;&gt;Linux 内存管理(2): 分页&lt;/h1&gt;

&lt;h2 id=&quot;页page&quot;&gt;页(page)&lt;/h2&gt;

&lt;p&gt;线性地址空间被分割为一个个&lt;strong&gt;页(page)&lt;/strong&gt;，32位系统中的页的大小通常为4K。
页内部连续的线性地址被映射到连续的物理地址中。每个VMA(虚拟内存区域，下面讲到）
的大小必须是页的整数倍。&lt;/p&gt;

&lt;h2 id=&quot;页框page-frame&quot;&gt;页框(page frame)&lt;/h2&gt;

&lt;p&gt;分页单元把物理地址空间被分割为一个个的&lt;strong&gt;页框(page frame)&lt;/strong&gt;。
处理器本身并不关心page frame，但是内核需要使用
page frame作为物理内存管理的单位。32位系统下，page frame的大小为4K，和虚拟内存
的page的大小一致。一个2G的物理地址空间结构示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/physicalAddressSpace.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同一块物理内存可以被map到不同的页上，并且有不同的标志。&lt;/p&gt;

&lt;p&gt;下图展示了一个进程的heap段中，虚拟内存空间（VMA）和物理内存页框(page frame)的关
系：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/heapMapped.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;中间的这堆page表示了VMA的范围，一个页通过页表最终能找到物理内
存中对应的页框。有些页没有箭头，这表示它的页表项（PTE）中的&lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt;标志位为0，
这可能是由于这个页中的内容从来没有被用过，或者被交换出去了(swapped out)。
此时，对这个页的访问，就会引发一个“缺页异常(page fault)”，这是非常常见的。&lt;/p&gt;

&lt;h2 id=&quot;页表page-tables&quot;&gt;页表(page tables)&lt;/h2&gt;

&lt;p&gt;把虚拟地址翻译为物理地址的过程是有软硬件联合完成的。包括操作系统，
MMU（存储器管理单元）中的地址翻译硬件和一个存放在内存中叫做
&lt;strong&gt;页表(page tables)&lt;/strong&gt;的数据结构，页表将虚拟页映射到物理页。每次翻译时，翻译硬件
都会读取页表，操作系统负责维护页表的内容，以及在硬盘和物理内存中传输页。&lt;/p&gt;

&lt;p&gt;每个进程都有自己的页表，
当前进程切换发生时，用户空间的页表也一起切换。每个进程的&lt;code class=&quot;highlighter-rouge&quot;&gt;task_struct&lt;/code&gt;中的内存
描述符&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;中有一个域&lt;code class=&quot;highlighter-rouge&quot;&gt;pgd&lt;/code&gt;，就指向这个进程的页表。&lt;/p&gt;

&lt;h3 id=&quot;页表项&quot;&gt;页表项&lt;/h3&gt;

&lt;p&gt;每个页在页表中都对应了一个&lt;strong&gt;页表项(page table entry, PTE)&lt;/strong&gt;，一个32位
系统的页表项如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/x86PageTableEntry4KB.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;内核可以读取或设置页表项的每一个标志，其中，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt;表示这个内存页当前是否在物理内存中，为0时，表示该页不在物理内存中，此时
PTE中的地址如果为空，表示这个页还没有分配，如果不为空，则代表这个页在硬盘上
的位置。此时对这个页的访问将引发一个&lt;strong&gt;缺页错误(page fault)&lt;/strong&gt;。这一位为0时，
内核可以对其他的标志做任何设置。这一位为1时，PTE中的地址就代表该页在物理内
存中的地址。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R/W&lt;/code&gt;标志表示是否是只读。&lt;code class=&quot;highlighter-rouge&quot;&gt;U/S&lt;/code&gt;标志代表user/supervisor，为0时，这一页只能被
内核访问。这些标志用于实现只读的虚拟内存以及用来保护内核空间。由于一个页中
的所有内容都有同样的&lt;code class=&quot;highlighter-rouge&quot;&gt;R/W&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;U/S&lt;/code&gt;等标志，所以页是内存保护的最小单位。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;标志表示&lt;strong&gt;脏(dirty)&lt;/strong&gt;和&lt;strong&gt;accessed&lt;/strong&gt;。当一个页发生过写操作，就说这个
页是脏的，一个页被读或者写过，就说这个页是accessed的。对于这两个标志，进程
只能去设置它们，但只有内核才能清除它们。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;地址的翻译&quot;&gt;地址的翻译&lt;/h2&gt;

&lt;p&gt;虚拟地址到物理地址的翻译是由软硬件配合完成的。CPU中的一个寄存器，页表基址寄存器
(Page Table Base Register, PTBR)指向&lt;strong&gt;当前&lt;/strong&gt;页表。对于一个n位的虚拟地址，可以分
为两部分：一个 p 位的虚拟页面便宜(Virtual Page Offset, VPO)，和一个 n-p 位的
虚拟页号(Virtual Page Number, VPN)。在命中的情况下，翻译的过程就是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;CPU生成一个虚拟地址，并传送给MMU；&lt;/li&gt;
  &lt;li&gt;MMU利用VPN来选择适当的PTE，继而找到对应物理页的起始地址；&lt;/li&gt;
  &lt;li&gt;物理页面的起始地址再加上VPO，就得到了这个虚拟地址对应的物理地址。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;img/mm_02_page_page_hit.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意，由于物理页面和虚拟页面大小相同，所以偏移也一样。&lt;/p&gt;

&lt;p&gt;如果没有命中，则翻译过程是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;CPU生成一个虚拟地址，并传送给MMU。&lt;/li&gt;
  &lt;li&gt;MMU利用VPN来选择适当的PTE，发现PTE中的有效位是零，于是MMU就触发了一次异常。&lt;/li&gt;
  &lt;li&gt;该异常导致CPU的控制被传递到操作系统内核中的缺页异常处理程序。&lt;/li&gt;
  &lt;li&gt;缺页处理程序确定出物理内存中的牺牲页，如果该页面已经被修改，则把它换出到磁
盘。&lt;/li&gt;
  &lt;li&gt;缺页处理程序调入新的页面，并更新PTE。&lt;/li&gt;
  &lt;li&gt;缺页处理程序返回原来的进程，再次执行导致缺页的指令。这次就会命中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;img/mm_02_page_page_not_hit.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用高速缓存sram&quot;&gt;使用高速缓存SRAM&lt;/h3&gt;

&lt;p&gt;在CPU和物理内存之间，还有几层高速SRAM高速缓存。对于地址翻译，SRAM中缓存的内容
是物理地址，也就是说，地址翻译发生在高速缓存查找之前，SRAM中有对页表条目的缓存
。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/mm_02_page_page_and_sram.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;利用tlb加速地址翻译&quot;&gt;利用TLB加速地址翻译&lt;/h3&gt;

&lt;p&gt;MMU内部包括了一个关于PTE的小缓存，叫做
&lt;strong&gt;翻译后备缓冲器(Translation Lookaside Buffer, TLB)&lt;/strong&gt;，这是一个虚拟寻址的小缓存
，每一行都保存着一个由单个PTE组成的块。加上TLB后，地址翻译的示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/mm_02_page_page_and_tlb.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;页表的组织&quot;&gt;页表的组织&lt;/h3&gt;

&lt;p&gt;基于效率的考虑，处理器一般都采用多级目录的方式来组织页表。从2.6.11版本之后，
Linux使用4级分页模型，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/LinuxPagingModel.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/6097773/&quot;&gt;Linux内核设计与实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://oss.org.cn/kernel-book/ch06/6.3.1.htm&quot;&gt;深入分析Linux内核源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/2287506/&quot;&gt;深入理解Linux内核&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/5333562/&quot;&gt;深入理解计算机系统&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.win.tue.nl/~aeb/linux/lk/lk.html&quot;&gt;The Linux Kernel&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory&quot;&gt;Anatomy of a Program in Memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation&quot;&gt;Memory Translation and Segmentation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory&quot;&gt;How The Kernel Manages Your Memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/category/linux&quot;&gt;Page Cache, the Affair Between Memory and Files&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/the-thing-king&quot;&gt;The Thing King&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection&quot;&gt;CPU Rings, Privilege, and Protection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 17 Feb 2020 21:09:09 +0800</pubDate>
        <link>http://gaopenghigh.github.io/2020/02/17/2013-11-07-mm_02_page.html</link>
        <guid isPermaLink="true">http://gaopenghigh.github.io/2020/02/17/2013-11-07-mm_02_page.html</guid>
        
        
      </item>
    
      <item>
        <title></title>
        <description>&lt;h1 id=&quot;linux-内存管理1分段segment&quot;&gt;Linux 内存管理(1)：分段(segment)&lt;/h1&gt;

&lt;h3 id=&quot;基础概念&quot;&gt;基础概念&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;逻辑地址&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指程序中看到的地址，之后我们会看到，在Intel的分段架构中，每个逻辑地址都由一个
段（segment）加上一个偏移量（offset）组成。
对于每一个进程来说，它看到的都是一整个虚拟内存空间，它并不知道实际情况是很多个
进程共用一块小得多的物理内存。实现这种效果的技术，就是内存管理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;线性地址&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;或者说是线性地址空间，表示CPU能够寻址的整个地址空间。通常情况下线性地址空间
比物理内存大。对于32位系统，线性地址空间就有4G大小。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;物理地址&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;就是真实的内存，通过芯片控制存储和读取，显然空间有限。CPU通过前端总线（
Front Side Bus）连接到北桥（Northbridgh），再连接到内存条。在FSB中交换的内存
地址都是真实的内存地址。&lt;/p&gt;

&lt;p&gt;程序使用逻辑地址，操作内存使用的是物理地址，所以必须把逻辑地址转换为物理地址。
主要的转换流程如下图（来自
&lt;a href=&quot;http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation&quot;&gt;Memory Translation and Segmentation&lt;/a&gt;
）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/memoryTranslation.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;硬件中的分段处理器怎么访问物理内存&quot;&gt;硬件中的分段–处理器怎么访问物理内存&lt;/h3&gt;

&lt;h4 id=&quot;分段segmentation&quot;&gt;分段(Segmentation)&lt;/h4&gt;

&lt;p&gt;Intel处理器以两种不同的方式进行地址转换：实模式（real-mode）和保护模式（
protected-mode）。一般情况下处理器工作在protected-mode，real-mode存在的原因一是
与早期的处理器兼容，二是在系统启动（自举）的过程中会使用到。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;历史&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;原始的8086芯片具有16位的寄存器，于是它可以使用2^16=64K字节的内存。为了使用更多
的内存，Intel引入了“段寄存器(segment register)”，该寄存器的作用就是告诉CPU
到底应该使用哪个64K的“段”。段寄存器中指示了一个64K段的起始地址，于是程序中的16
位地址就相当于一个偏移（offset）。一共有4个段寄存器，一个给Stack使用(ss)，一个
给程序代码使用（cs），还有两个给程序数据使用(ds, es)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;现在&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;段寄存器在现在仍然在使用，其中存着16位的&lt;strong&gt;Segment selectors&lt;/strong&gt;。
其使用的方法在real-mode和protected-mode下不太一样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;real-mode&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在real-mode下，段寄存器中的内容需要标识一个段的起始地址。基于硬件成本等的考虑，
Intel使用段寄存器中的4位，这样就能分出2^4=16个64K的段，一共就是1M。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;protected-mode&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在32位的protected-mode下，段寄存器中的内容叫做段选择符（segment selectors)，
Segment selector代表了一个叫做“段描述符（segment descriptors)”的表的索引。
这个表实际上就是一个数组，每个元素有8个字节，每个元素（segment descriptor）表示
一个段。Segment descriptor的结构如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/segmentDescriptor.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Base Address中的32位地址代表了这个段的起始地址&lt;/li&gt;
  &lt;li&gt;Limit表示这个段有多大&lt;/li&gt;
  &lt;li&gt;DPL代表段描述符的等级，控制对段的访问。可以是0到3的数字。0代表最高等级（内核态），3代表最低等级（用户态）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些段描述符被存在两个表里面：GDT(Global Descriptor Table)和LDT
(Local Descriptor Table)。每个CPU核都有一个叫做&lt;strong&gt;gdtr&lt;/strong&gt;的寄存器，里面放着GDT的
地址。所以在16位的段寄存器中的内容（segment selector）就有如下的结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/segmentSelectorDataAndCode.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中，&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;TI代表是GDT或者是LDT&lt;/li&gt;
  &lt;li&gt;Index代表这个段在表中的索引&lt;/li&gt;
  &lt;li&gt;PRL指Requested Privilege Level&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结下来就是，CPU通过段寄存器存储segment selector，通过segment selector在GDT表
或者LDT表中找到对应的segment 的segment descriptor，获取到这个段的Base Address、
大小等信息。如图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/segmentSelector_segmentDescriptor.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;途中的“Noprogrammable Reigster”表示一组非编程寄存器，它存储segment selector指定
的segment descriptor，这样不用每次都去查GDT，能够更快地进行逻辑地址到线性地址的
转换。&lt;/p&gt;

&lt;p&gt;把Base Address和逻辑地址(logical address)相加，就得到了线性地址(linear address)
。也就是说，程序使用的是逻辑地址，经过分段机制，CPU把逻辑地址转换成了线性地址
（linear address），再经过分页机制，最后得到了物理地址。&lt;/p&gt;

&lt;p&gt;整个过程可以通过下图表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/logical_address_convert.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分段单元（segment unit）执行的过程如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从段寄存器获取segment selector&lt;/li&gt;
  &lt;li&gt;根据segment selector的内容从GDT或者LDT中获取segment descriptor，GDT的位置由
gdtr寄存器存储&lt;/li&gt;
  &lt;li&gt;根据segment descriptor获取到这个段的Base Address，把Base Address和逻辑地址
(logical address)相加，就得到了线性地址(linear address)。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;flat-mode&quot;&gt;Flat Mode&lt;/h4&gt;

&lt;p&gt;这里就有个问题：如果寄存器还在是16位的，那么每个程序的逻辑地址就只有64K大小。
但我们又想使用更大的物理内存，于是使用了分段机制，让逻辑地址加上了一个段地址，
得到一个线性地址，代表某个段中的内存，最后在通过分页机制转换为物理地址。但是
在32位CPU中，寄存器和指令本身就能对整个线性地址进行寻址，为什么
还要做这个分段呢？直接把Base Address置为0不就好了，这样逻辑地址和线性地址实际上
就相等了。事实上的确可以，Intel把这种模式叫做flat model，这种模式也正是内核所
使用的。&lt;/p&gt;

&lt;h4 id=&quot;地址转换概览&quot;&gt;地址转换概览&lt;/h4&gt;

&lt;p&gt;下面的图代表了一个用户态中的程序，发出一个JMP命令时发生的情况：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/protectedModeSegmentation.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Linux主要使用的就是4个段：用户态下的数据段和代码段，内核态下的数据段和代码段。
运行过程中，每个CPU内核都有自己的GDT。所以主要有4个GDT：两个给内核态的
code和data用，另外两个给用户态下的code和data使用。&lt;/p&gt;

&lt;p&gt;值得注意的是，在GDT中的数据都是以cache line的大小对齐的。&lt;/p&gt;

&lt;h3 id=&quot;底层的权限和等级&quot;&gt;底层的权限和等级&lt;/h3&gt;

&lt;h4 id=&quot;介绍&quot;&gt;介绍&lt;/h4&gt;

&lt;p&gt;这里所指的权限和等级（privilege）不是root和普通用户这些等级，而是对系统底层资源
的权限控制。所谓底层资源，主要包括三种：内存、I/O端口、对特定指令的执行权限。&lt;/p&gt;

&lt;p&gt;Intel架构中，包括了4个等级，用数字0到3代替，0的等级最高，3的等级最低。在任意一
个时刻，CPU都运行在某个等级中，这就限制了CPU不能做某些事情。&lt;/p&gt;

&lt;p&gt;对于Linux内核以及大多数其它内核，事实上只使用了两个等级：0和3。&lt;/p&gt;

&lt;p&gt;大概有15个指令处于等级0中，比如对内存和I/O端口的操作相关的指令。
试图在其他等级运行这些指令，比如当程序试图操作不属于它的内存时。就会导致一些错
误。&lt;/p&gt;

&lt;p&gt;正是因为有这些限制，用户态的程序不能直接对内存、I/O等进行操作，而只能通过系统
调用实现。&lt;/p&gt;

&lt;h4 id=&quot;cpu如何知道运行于哪个等级下&quot;&gt;CPU如何知道运行于哪个等级下&lt;/h4&gt;

&lt;p&gt;通过前面的讨论，我们知道，在段寄存器中存着叫做“段选择器（segment selector）”的
内容，里面有个字段叫RPL或者CPL：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RPL，Requested Privilege Level，对于数据段寄存器ds或者stack段寄存器ss。RPL
的内容不能被mov等指令修改，而只能通过那些对程序运行流程进行修改的指令，比如
call等， 来进行设置。&lt;/li&gt;
  &lt;li&gt;CPL，Current Privilege Level，对于代码段寄存器cs。前面说到，RPL可以通过代码
进行修改，而CPL的内容被CPU自己维护，它总是等于CPU当前的等级。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，在任何时候，通过查看cs的CPL，就可以知道CPU工作在哪个等级下。&lt;/p&gt;

&lt;h4 id=&quot;cpu对内存的保护&quot;&gt;CPU对内存的保护&lt;/h4&gt;

&lt;p&gt;当一个段选择器（segment selector）加载到寄存器，或者当通过线性地址访问一页内存
时，CPU都会对内存进行保护，其保护的原理如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/segmentProtection.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MAX()选择RPL和CPL中最小的一个等级，把它和段描述符(segment descriptor)中的DPL进
行比较，当大于DPL时（即当前的CPU的等级CPL或者需要的等级RPL小于这个段的等级时）
，就触发错误。&lt;/p&gt;

&lt;p&gt;但由于&lt;strong&gt;现在的内核都是使用的是flat模式&lt;/strong&gt;，意味着用户态的段可以使用整个线性地址
空间，所以CPU对内存真正的保护体现在分页，即线性地址转换为物理地址的时候。
内存以页为单位进行管理，每个页由页表项（page table entry）进行描述，PTE中有
两个字段和保护有关系：一个是supervisor flag，另一个是read/write flag。
当supervisor flag被标记时，这页的内容就不能在等级3下进行访问。&lt;/p&gt;

&lt;p&gt;Linux的fork使用“写时复制”技术，当子进程被fork出来时，父进程的内存页通过
read/write flag被标记为只读，并且和子进程共享，当任何一个进程试图修改其内容时，
就触发一个错误来通知内核，复制一份内容并标记为可可读/写。&lt;/p&gt;

&lt;p&gt;等级的切换通过中断机制进行。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/6097773/&quot;&gt;Linux内核设计与实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://oss.org.cn/kernel-book/ch06/6.3.1.htm&quot;&gt;深入分析Linux内核源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/2287506/&quot;&gt;深入理解Linux内核&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.win.tue.nl/~aeb/linux/lk/lk.html&quot;&gt;The Linux Kernel&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory&quot;&gt;Anatomy of a Program in Memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation&quot;&gt;Memory Translation and Segmentation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory&quot;&gt;How The Kernel Manages Your Memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/category/linux&quot;&gt;Page Cache, the Affair Between Memory and Files&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/the-thing-king&quot;&gt;The Thing King&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection&quot;&gt;CPU Rings, Privilege, and Protection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 17 Feb 2020 21:09:09 +0800</pubDate>
        <link>http://gaopenghigh.github.io/2020/02/17/2013-11-06-mm_01_segment.html</link>
        <guid isPermaLink="true">http://gaopenghigh.github.io/2020/02/17/2013-11-06-mm_01_segment.html</guid>
        
        
      </item>
    
      <item>
        <title>工程师文化和技术团队的管理</title>
        <description>&lt;p&gt;写于 2019 年 6 月 16 日。&lt;/p&gt;

&lt;h2 id=&quot;目的&quot;&gt;目的&lt;/h2&gt;

&lt;p&gt;在很多方面，管理者和员工拥有同样的&lt;strong&gt;目的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;首先，都希望&lt;strong&gt;提升幸福感&lt;/strong&gt;。包括物质奖励、成就感、愉悦感等等。&lt;/p&gt;

&lt;p&gt;其次是希望&lt;strong&gt;提升个人能力&lt;/strong&gt;：管理能力、技术能力、业务能力、影响力等等。&lt;/p&gt;

&lt;p&gt;幸福感代表当下更好的生活，而能力提升用来保证未来更好的生活。&lt;/p&gt;

&lt;p&gt;同样的，员目的工更多的是通过自己的努力，而管理者需要依靠团队的每一个成员。对于计算机技术团队来说，&lt;strong&gt;建立良好的工程师文化，是提升团队能力、提高执行力、打造优秀团队的重要途径&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;什么是好的工程师文化&quot;&gt;什么是好的工程师文化&lt;/h2&gt;

&lt;h3 id=&quot;尊重&quot;&gt;尊重&lt;/h3&gt;

&lt;p&gt;管理者和员工都是&lt;strong&gt;平等&lt;/strong&gt;的，只有职级区别，没有优劣之差，没有谁高人一等。&lt;/p&gt;

&lt;p&gt;一个人可能某方面做的不好，但在其他一些方面则是专家。而一个技术上非常优秀的人，同时也可能是一个难以相处的人。&lt;/p&gt;

&lt;p&gt;关键是&lt;strong&gt;同理心&lt;/strong&gt;，真的站在对方的角度看问题，只有理解了对方处境和诉求，才知道行为背后的原因，才有可能进行干预，让事情朝着更好的方向发展。&lt;/p&gt;

&lt;p&gt;先&lt;strong&gt;承认自己的能力的有限&lt;/strong&gt;，然后让每个成员意识到自己能力的有限。每个人都会犯错，团队的一个价值，就在于能纠正一些个人错误。&lt;/p&gt;

&lt;p&gt;杜绝傲慢、也不要过分谦虚，需要的是&lt;strong&gt;理性&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;真诚&quot;&gt;真诚&lt;/h3&gt;

&lt;p&gt;公司和员工是&lt;strong&gt;合作&lt;/strong&gt;关系，目标是要双赢。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们在建造教堂、而不是在搬砖&lt;/strong&gt;。管理者需要详细清晰地阐述自己的任务和目标，当前是什么处境、有什么基础、又有哪些困难。每个成员同样要明确地知道其他成员的任务和目标。&lt;/p&gt;

&lt;p&gt;不要说大话、空话、套话，不要用高大上的使命感价值观来粉饰不合理。&lt;/p&gt;

&lt;p&gt;表扬和批判都要&lt;strong&gt;言之有物&lt;/strong&gt;，对事不对人。专注在问题的解决，为的是让彼此都更好。&lt;/p&gt;

&lt;h3 id=&quot;连接兴趣能力和工作&quot;&gt;连接兴趣、能力和工作&lt;/h3&gt;

&lt;p&gt;尽可能地让每个人做自己感兴趣的工作。整个团队的核心任务，需要是让每个成员都认可并感兴趣的。&lt;/p&gt;

&lt;p&gt;尽可能地让每个人爱上自己做的事，兴趣可以转变，工作方式可以转变，&lt;strong&gt;把枯燥的工作能转化为有挑战的有趣的工作&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;尽可能地让每个人做能发挥自己能力的事，获得成就感。&lt;/p&gt;

&lt;h3 id=&quot;用事实说话&quot;&gt;用事实说话&lt;/h3&gt;

&lt;p&gt;好不好，用事实证明，而不是靠 PPT。&lt;/p&gt;

&lt;p&gt;用数据做决定，而不是先有了决定，再挑选数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;任何决定之前，给出理由&lt;/strong&gt;。管理者更不能拍脑袋。&lt;/p&gt;

&lt;h3 id=&quot;重视技术基础的建设&quot;&gt;重视技术基础的建设&lt;/h3&gt;

&lt;p&gt;技术基础往往不能提升创造业务指标，但却是长久发展必不可少的前提。管理者需要让升下级都明确地知道一个技术基础的意义。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;软件工程没有速成&lt;/strong&gt;，速成往往意味着技术债务，不解决只会越来越严重，变成定时炸弹。管理者要避免技术债务的出现。&lt;/p&gt;

&lt;p&gt;对于已有的技术债务要计划解决。并且作为明确的工作任务进行分配，设计清晰地考察方法。管理者需要通过绩效目标等方式来保证，完成这类任务的价值，不能低于业务类任务的价值。&lt;/p&gt;

&lt;h3 id=&quot;最大程度地自动化&quot;&gt;最大程度地自动化&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;工程师不是操作工&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;工程师的价值在于让机器完成工作。人会犯错，机器不会。如果机器错了，那是代码没写好，改进它。&lt;/p&gt;

&lt;p&gt;打造快速迭代的能力，UT/CI/CodeReview/CD，每个工程师都有能力让系统变得更好，而不需要特权。&lt;/p&gt;

&lt;h3 id=&quot;拥抱开源精神&quot;&gt;拥抱开源精神&lt;/h3&gt;

&lt;p&gt;学习、使用、回馈开源社区。&lt;/p&gt;

&lt;p&gt;像运营开源项目一样运营自己的代码，让别人能快速用起来。&lt;/p&gt;

&lt;p&gt;拥有详细的文档，解释背景、原理和基础知识，告诉别人怎么用起来，怎么做贡献。&lt;/p&gt;

&lt;p&gt;注重代码质量，标准的 Code Review，使用自动化测试。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码没有 Owner，每个人都能自由修改&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;打造学习氛围&quot;&gt;打造学习氛围&lt;/h3&gt;

&lt;p&gt;软件工程不是计件劳动，工程师需要时间思考、学习。&lt;/p&gt;

&lt;p&gt;把分享作为例行任务。分享不应限制与当前工作用得到的，或是本专业的。&lt;/p&gt;

&lt;p&gt;让所有人都知道，分享人是最大的受益者。&lt;/p&gt;

</description>
        <pubDate>Sun, 16 Jun 2019 15:00:00 +0800</pubDate>
        <link>http://gaopenghigh.github.io/thoughts/2019/06/16/%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%96%87%E5%8C%96%E5%92%8C%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E7%9A%84%E7%AE%A1%E7%90%86.html</link>
        <guid isPermaLink="true">http://gaopenghigh.github.io/thoughts/2019/06/16/%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%96%87%E5%8C%96%E5%92%8C%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E7%9A%84%E7%AE%A1%E7%90%86.html</guid>
        
        
        <category>Thoughts</category>
        
      </item>
    
  </channel>
</rss>
