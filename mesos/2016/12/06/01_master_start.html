<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Mesos 源码学习(1) Mesos Master 的启动</title>
  <meta name="description" content="Mesos Master 启动相关的代码在 src/master/main.cpp 中。">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="/mesos/2016/12/06/01_master_start.html">
  <link rel="alternate" type="application/rss+xml" title="做美好的人，做酷的事" href="/feed.xml">
  <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">做美好的人，做酷的事</a>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <!-- This css contains the default style for TOC -->
    <link rel="stylesheet" type="text/css" media="screen" href="/css/toc.css">
    <!--
    <link rel="stylesheet" type="text/css" media="screen" href="/css/monokai.css">
    <style>
        pre {background-color:#272822;}
    </style>
    -->
    <h1 class="post-title" itemprop="name headline">Mesos 源码学习(1) Mesos Master 的启动</h1>
    <p class="post-meta"><time datetime="2016-12-06T11:00:00+08:00" itemprop="datePublished">Dec 6, 2016</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <div id="toc-container">
  <table class="toc" id="toc">
    <tbody>
      <tr>
        <td>
          <div id="toctitle">
            <h2>Contents</h2>
          </div>
          <ul>
            <li class="toc_level-1 toc_section-1">
              <a href="#tocAnchor-1-1"><span class="tocnumber">1</span> <span class="toctext">解析 flags 参数</span></a>
            </li>
            <li class="toc_level-1 toc_section-2">
              <a href="#tocAnchor-1-2"><span class="tocnumber">2</span> <span class="toctext">初始化 master process</span></a>
            </li>
            <li class="toc_level-1 toc_section-3">
              <a href="#tocAnchor-1-3"><span class="tocnumber">3</span> <span class="toctext">初始化 Version Process</span></a>
            </li>
            <li class="toc_level-1 toc_section-4">
              <a href="#tocAnchor-1-4"><span class="tocnumber">4</span> <span class="toctext">初始化 firewall rules</span></a>
            </li>
            <li class="toc_level-1 toc_section-5">
              <a href="#tocAnchor-1-5"><span class="tocnumber">5</span> <span class="toctext">加载 module 和 anonymous modules</span></a>
            </li>
            <li class="toc_level-1 toc_section-6">
              <a href="#tocAnchor-1-6"><span class="tocnumber">6</span> <span class="toctext">初始化 Hooks</span></a>
            </li>
            <li class="toc_level-1 toc_section-7">
              <a href="#tocAnchor-1-7"><span class="tocnumber">7</span> <span class="toctext">创建 Allocator</span></a>
            </li>
            <li class="toc_level-1 toc_section-8">
              <a href="#tocAnchor-1-8"><span class="tocnumber">8</span> <span class="toctext">Registry storage</span></a>
            </li>
            <li class="toc_level-1 toc_section-9">
              <a href="#tocAnchor-1-9"><span class="tocnumber">9</span> <span class="toctext">State</span></a>
            </li>
            <li class="toc_level-1 toc_section-10">
              <a href="#tocAnchor-1-10"><span class="tocnumber">10</span> <span class="toctext">创建 Master contendor 和 detector</span></a>
            </li>
            <li class="toc_level-1 toc_section-11">
              <a href="#tocAnchor-1-11"><span class="tocnumber">11</span> <span class="toctext">初始化 Authorizer</span></a>
            </li>
            <li class="toc_level-1 toc_section-12">
              <a href="#tocAnchor-1-12"><span class="tocnumber">12</span> <span class="toctext">设置 Slave removal rate limiter</span></a>
            </li>
            <li class="toc_level-1 toc_section-13">
              <a href="#tocAnchor-1-13"><span class="tocnumber">13</span> <span class="toctext">创建 master process</span></a>
            </li>
          </ul>
        </td>
      </tr>
    </tbody>
  </table>
</div><p>Mesos Master 启动相关的代码在 <code class="highlighter-rouge">src/master/main.cpp</code> 中。</p>

<h2 id="tocAnchor-1-1">解析 flags 参数</h2>

<p>通过解析以 <code class="highlighter-rouge">MESOS_</code> 开头的环境变量，来初始化一些参数，并验证参数的合法性。
具体的参数参考 <a href="http://mesos.apache.org/documentation/latest/configuration/">Mesos Configuration</a>。</p>

<h2 id="tocAnchor-1-2">初始化 master process</h2>

<p>初始化一个 name 为 <code class="highlighter-rouge">master</code> 的 process :</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
  <span class="c1">// This should be the first invocation of `process::initialize`. If it returns
</span>  <span class="c1">// `false`, then it has already been called, which means that the
</span>  <span class="c1">// authentication realm for libprocess-level HTTP endpoints was not set to the
</span>  <span class="c1">// correct value for the master.
</span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">process</span><span class="o">::</span><span class="n">initialize</span><span class="p">(</span>
          <span class="s">"master"</span><span class="p">,</span>
          <span class="n">READWRITE_HTTP_AUTHENTICATION_REALM</span><span class="p">,</span>
          <span class="n">READONLY_HTTP_AUTHENTICATION_REALM</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">EXIT</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"The call to `process::initialize()` in the master's "</span>
                       <span class="o">&lt;&lt;</span> <span class="s">"`main()` was not the function's first invocation"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p>其中，<code class="highlighter-rouge">process::initialize()</code> 定义在 <code class="highlighter-rouge">3rdparty/libprocess/include/process/process.hpp</code> 中：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cm">/**
 * Initialize the library.
 *
 * **NOTE**: `libprocess` uses Google's `glog` and you can specify options
 * for it (e.g., a logging directory) via environment variables.
 *
 * @param delegate Process to receive root HTTP requests.
 * @param readwriteAuthenticationRealm The authentication realm that read-write
 *     libprocess-level HTTP endpoints will be installed under, if any.
 *     If this realm is not specified, read-write endpoints will be installed
 *     without authentication.
 * @param readonlyAuthenticationRealm The authentication realm that read-only
 *     libprocess-level HTTP endpoints will be installed under, if any.
 *     If this realm is not specified, read-only endpoints will be installed
 *     without authentication.
 * @return `true` if this was the first invocation of `process::initialize()`,
 *     or `false` if it was not the first invocation.
 *
 * @see [glog](https://google-glog.googlecode.com/svn/trunk/doc/glog.html)
 */</span>
<span class="kt">bool</span> <span class="n">initialize</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">Option</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">delegate</span> <span class="o">=</span> <span class="n">None</span><span class="p">(),</span>
    <span class="k">const</span> <span class="n">Option</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">readwriteAuthenticationRealm</span> <span class="o">=</span> <span class="n">None</span><span class="p">(),</span>
    <span class="k">const</span> <span class="n">Option</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">readonlyAuthenticationRealm</span> <span class="o">=</span> <span class="n">None</span><span class="p">());</span>
</code></pre>
</div>

<h2 id="tocAnchor-1-3">初始化 Version Process</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
    <span class="n">spawn</span><span class="p">(</span><span class="k">new</span> <span class="n">VersionProcess</span><span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p>其中 VersionProcess 就是一个 name 为 “version” 的 process，负责打印版本号的。
VersionProcess 定义在 <code class="highlighter-rouge">src/version/version.hpp</code> 和 <code class="highlighter-rouge">src/version/version.cpp</code> 中。</p>

<h2 id="tocAnchor-1-4">初始化 firewall rules</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
  <span class="c1">// Initialize firewall rules.
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="p">.</span><span class="n">firewall_rules</span><span class="p">.</span><span class="n">isSome</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Owned</span><span class="o">&lt;</span><span class="n">FirewallRule</span><span class="o">&gt;&gt;</span> <span class="n">rules</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">Firewall</span> <span class="n">firewall</span> <span class="o">=</span> <span class="n">flags</span><span class="p">.</span><span class="n">firewall_rules</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">firewall</span><span class="p">.</span><span class="n">has_disabled_endpoints</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">hashset</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">paths</span><span class="p">;</span>

      <span class="n">foreach</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">path</span><span class="p">,</span> <span class="n">firewall</span><span class="p">.</span><span class="n">disabled_endpoints</span><span class="p">().</span><span class="n">paths</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">paths</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="n">rules</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="k">new</span> <span class="n">DisabledEndpointsFirewallRule</span><span class="p">(</span><span class="n">paths</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">process</span><span class="o">::</span><span class="n">firewall</span><span class="o">::</span><span class="n">install</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">rules</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p>通过 firewall 可以设置一些 endpoint 不可用。</p>

<h2 id="tocAnchor-1-5">加载 module 和 anonymous modules</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="p">.</span><span class="n">modules</span><span class="p">.</span><span class="n">isSome</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">Try</span><span class="o">&lt;</span><span class="n">Nothing</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">ModuleManager</span><span class="o">::</span><span class="n">load</span><span class="p">(</span><span class="n">flags</span><span class="p">.</span><span class="n">modules</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">isError</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">EXIT</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"Error loading modules: "</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">error</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

    <span class="c1">// Create anonymous modules.
</span>  <span class="n">foreach</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">ModuleManager</span><span class="o">::</span><span class="n">find</span><span class="o">&lt;</span><span class="n">Anonymous</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">Try</span><span class="o">&lt;</span><span class="n">Anonymous</span><span class="o">*&gt;</span> <span class="n">create</span> <span class="o">=</span> <span class="n">ModuleManager</span><span class="o">::</span><span class="n">create</span><span class="o">&lt;</span><span class="n">Anonymous</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">create</span><span class="p">.</span><span class="n">isError</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">EXIT</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">)</span>
        <span class="o">&lt;&lt;</span> <span class="s">"Failed to create anonymous module named '"</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">"'"</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">ModuleManager::load()</code> 定义在 <code class="highlighter-rouge">src/module/manager.hpp</code> 和 <code class="highlighter-rouge">src/module/manager.cpp</code>。</p>

<p>ModuleManager 会动态地加载命令行中指定的 module，就是一个个地加载动态链接库，
然后为每个 module 创建一个 singleton，同时还维护一个 module name 到 module 指针的映射表。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Mesos module loading.
//
// Phases:
</span>
<span class="c1">// 1. Load dynamic libraries that contain modules from the Modules
//    instance which may have come from a commandline flag.
// 2. Verify versions and compatibilities.
//   a) Library compatibility. (Module API version check)
//   b) Module compatibility. (Module Kind version check)
// 3. Instantiate singleton per module. (happens in the library)
// 4. Bind reference to use case. (happens in Mesos)
</span></code></pre>
</div>

<p>关于 module 参考 <a href="http://mesos.apache.org/documentation/latest/modules/">Mesos Modules</a>。</p>

<p>这里简要说明通过 Mesos Module 可以做什么：</p>
<ol>
  <li>实现自己的 Allocator：把自己实现的 Allocator 编译成 so 文件，通过命令行 <code class="highlighter-rouge">--modules</code> 和 <code class="highlighter-rouge">--allocator</code> 指定自己的 Allocator。</li>
  <li>权限认证模块 Authenticatee 和 Authenicator</li>
  <li>Isolator，实现自己的资源隔离，当我们有某种特殊的资源时，就需要实现一个 Isolator</li>
  <li>Master Contender 和 Detector，默认 Mesos Master 使用 ZK 进行选主，可以通过实现特定的 Contender 和 Detector 来使用其它的服务来实现选主，比如 etcd 和 consul。</li>
  <li>提供 Hook，Hook 是一些定义好的接口，这些 Hook 会在某些阶段被调用到，Module 可以选择实现其中的某些 Hook 来实现某种需求；</li>
</ol>

<h2 id="tocAnchor-1-6">初始化 Hooks</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code>  <span class="c1">// Initialize hooks.
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="p">.</span><span class="n">hooks</span><span class="p">.</span><span class="n">isSome</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">Try</span><span class="o">&lt;</span><span class="n">Nothing</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">HookManager</span><span class="o">::</span><span class="n">initialize</span><span class="p">(</span><span class="n">flags</span><span class="p">.</span><span class="n">hooks</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">isError</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">EXIT</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"Error installing hooks: "</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">error</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">HookManager</code> 定义在 <code class="highlighter-rouge">src/hook/manager.hpp</code> 和 <code class="highlighter-rouge">src/hook/manager.cpp</code> 中。</p>

<p>目前有如下一些 Hook：</p>
<ul>
  <li><code class="highlighter-rouge">masterLaunchTaskLabelDecorator</code>：在 Master launch task 时调用，为新的 task 提供一些 label，这些 label 会覆盖原来的那些。</li>
  <li><code class="highlighter-rouge">masterSlaveLostHook</code>：当一个 slave lost 时，该 hook 被调用。</li>
  <li><code class="highlighter-rouge">slaveAttributesDecorator</code>：Slave 初始化时调用，该 hook 为这个 slave 创建 attributes，然后 slave 会把自身的信息（包含 attribute）通知到 master。</li>
  <li><code class="highlighter-rouge">slaveExecutorEnvironmentDecorator</code>：slave 启动一个 executor 时，会调用该 hook 为 executor 创建环境变量。</li>
  <li><code class="highlighter-rouge">slavePostFetchHook</code>：当 slave 通过 fetcher 把需要的资源下载下来后会调用这个 hook 做一些处理</li>
  <li><code class="highlighter-rouge">slavePreLaunchDockerTaskExecutorDecorator</code>：slave在执行 docker 任务前调用这个 hook。</li>
  <li><code class="highlighter-rouge">slaveRemoveExecutorHook</code>：当一个 executor 被移除时，这个 hook 被调用，比如说可以做一些清理工作。</li>
  <li><code class="highlighter-rouge">slaveResourcesDecorator</code>：slave 初始化时被调用，为 slave 生成 resource</li>
  <li><code class="highlighter-rouge">slaveRunTaskLabelDecorator</code>：当 slave 从 master 收到要启动一个 task 的请求时，该 hook 被调用，生成一些 label 并且覆盖已有的 label。</li>
  <li><code class="highlighter-rouge">slaveTaskStatusDecorator</code>：当 executor 向 slave 报告 task status 时，该 hook 被调用，生成 task 的 status ，覆盖原来的。</li>
</ul>

<h2 id="tocAnchor-1-7">创建 Allocator</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code>  <span class="c1">// Create an instance of allocator.
</span>  <span class="k">const</span> <span class="n">string</span> <span class="n">allocatorName</span> <span class="o">=</span> <span class="n">flags</span><span class="p">.</span><span class="n">allocator</span><span class="p">;</span>
  <span class="n">Try</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">*&gt;</span> <span class="n">allocator</span> <span class="o">=</span> <span class="n">Allocator</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">allocatorName</span><span class="p">);</span>
</code></pre>
</div>

<p>Allocator 接口定义在 <code class="highlighter-rouge">include/mesos/allocator/allocator.hpp</code> 中：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">mesos</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">allocator</span> <span class="p">{</span>

<span class="cm">/**
 * Basic model of an allocator: resources are allocated to a framework
 * in the form of offers. A framework can refuse some resources in
 * offers and run tasks in others. Allocated resources can have offer
 * operations applied to them in order for frameworks to alter the
 * resource metadata (e.g. creating persistent volumes). Resources can
 * be recovered from a framework when tasks finish/fail (or are lost
 * due to an agent failure) or when an offer is rescinded.
 *
 * This is the public API for resource allocators.
 */</span>
<span class="k">class</span> <span class="nc">Allocator</span>
<span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">Allocator::create</code> 方法实现在 <code class="highlighter-rouge">src/master/allocator/allocator.cpp</code> 中:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">using</span> <span class="n">mesos</span><span class="o">::</span><span class="n">allocator</span><span class="o">::</span><span class="n">Allocator</span><span class="p">;</span>
<span class="k">using</span> <span class="n">mesos</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">master</span><span class="o">::</span><span class="n">allocator</span><span class="o">::</span><span class="n">HierarchicalDRFAllocator</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">Try</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">*&gt;</span> <span class="n">Allocator</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Create an instance of the default allocator. If other than the
</span>  <span class="c1">// default allocator is requested, search for it in loaded modules.
</span>  <span class="c1">// NOTE: We do not need an extra not-null check, because both
</span>  <span class="c1">// ModuleManager and built-in allocator factory do that already.
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">mesos</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">master</span><span class="o">::</span><span class="n">DEFAULT_ALLOCATOR</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">HierarchicalDRFAllocator</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">modules</span><span class="o">::</span><span class="n">ModuleManager</span><span class="o">::</span><span class="n">create</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>默认的 HierarchicalDRFAllocator 实现在 <code class="highlighter-rouge">src/master/allocator/mesos/hierarchical.hpp</code> 中：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">mesos</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">internal</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">master</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">allocator</span> <span class="p">{</span>
<span class="p">...</span>
<span class="k">class</span> <span class="nc">HierarchicalAllocatorProcess</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">HierarchicalAllocatorProcess</span><span class="o">&lt;</span><span class="n">DRFSorter</span><span class="p">,</span> <span class="n">DRFSorter</span><span class="p">,</span> <span class="n">DRFSorter</span><span class="o">&gt;</span>
<span class="n">HierarchicalDRFAllocatorProcess</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">MesosAllocator</span><span class="o">&lt;</span><span class="n">HierarchicalDRFAllocatorProcess</span><span class="o">&gt;</span>
<span class="n">HierarchicalDRFAllocator</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">class</span> <span class="nc">HierarchicalAllocatorProcess</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MesosAllocatorProcess</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">MesosAllocator</code> 和 <code class="highlighter-rouge">MesosAllocatorProcess</code> 都定义在 <code class="highlighter-rouge">src/master/allocator/mesos/allocator.hpp</code> :</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">mesos</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">internal</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">master</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">allocator</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">MesosAllocatorProcess</span><span class="p">;</span>
<span class="p">...</span>
<span class="c1">// The basic interface for all Process-based allocators.
</span><span class="k">class</span> <span class="nc">MesosAllocatorProcess</span> <span class="o">:</span> <span class="k">public</span> <span class="n">process</span><span class="o">::</span><span class="n">Process</span><span class="o">&lt;</span><span class="n">MesosAllocatorProcess</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">MesosAllocator</code> 包装了一个 Process-based Allocator，用了 libprocess 来提供 allocator 的服务：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// A wrapper for Process-based allocators. It redirects all function
// invocations to the underlying AllocatorProcess and manages its
// lifetime. We ensure the template parameter AllocatorProcess
// implements MesosAllocatorProcess by storing a pointer to it.
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">AllocatorProcess</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MesosAllocator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">mesos</span><span class="o">::</span><span class="n">allocator</span><span class="o">::</span><span class="n">Allocator</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="k">private</span><span class="o">:</span>
   <span class="n">MesosAllocatorProcess</span><span class="o">*</span> <span class="n">process</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>注意到 private 字段中包含了一个 process 的指针。
Allocator 对外的服务，都是通过这个 wrapper 提供的。比如：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">AllocatorProcess</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">MesosAllocator</span><span class="o">&lt;</span><span class="n">AllocatorProcess</span><span class="o">&gt;::</span><span class="n">requestResources</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">FrameworkID</span><span class="o">&amp;</span> <span class="n">frameworkId</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Request</span><span class="o">&gt;&amp;</span> <span class="n">requests</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">process</span><span class="o">::</span><span class="n">dispatch</span><span class="p">(</span>
      <span class="n">process</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="n">MesosAllocatorProcess</span><span class="o">::</span><span class="n">requestResources</span><span class="p">,</span>
      <span class="n">frameworkId</span><span class="p">,</span>
      <span class="n">requests</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>这个 wrapper 通过 <code class="highlighter-rouge">dispatch</code>，调用了对应 AllocatorProcess 的 <code class="highlighter-rouge">MesosAllocatorProcess::requestResources</code>
方法，传入了两个参数 <code class="highlighter-rouge">frameworkId</code> 和 <code class="highlighter-rouge">requests</code>。</p>

<h2 id="tocAnchor-1-8">Registry storage</h2>

<p>Registry storage 负责存储数据，根据参数，数据可以存储在：</p>
<ol>
  <li>内存</li>
  <li>ZK + Replicated Log</li>
  <li>本地 Replicated Log</li>
</ol>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="p">...</span>
      <span class="n">Try</span><span class="o">&lt;</span><span class="n">zookeeper</span><span class="o">::</span><span class="n">URL</span><span class="o">&gt;</span> <span class="n">url</span> <span class="o">=</span> <span class="n">zookeeper</span><span class="o">::</span><span class="n">URL</span><span class="o">::</span><span class="n">parse</span><span class="p">(</span><span class="n">flags</span><span class="p">.</span><span class="n">zk</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">url</span><span class="p">.</span><span class="n">isError</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">EXIT</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"Error parsing ZooKeeper URL: "</span> <span class="o">&lt;&lt;</span> <span class="n">url</span><span class="p">.</span><span class="n">error</span><span class="p">();</span>
      <span class="p">}</span>

      <span class="n">log</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Log</span><span class="p">(</span>
          <span class="n">flags</span><span class="p">.</span><span class="n">quorum</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span>
          <span class="n">path</span><span class="o">::</span><span class="n">join</span><span class="p">(</span><span class="n">flags</span><span class="p">.</span><span class="n">work_dir</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="s">"replicated_log"</span><span class="p">),</span>
          <span class="n">url</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">servers</span><span class="p">,</span>
          <span class="n">flags</span><span class="p">.</span><span class="n">zk_session_timeout</span><span class="p">,</span>
          <span class="n">path</span><span class="o">::</span><span class="n">join</span><span class="p">(</span><span class="n">url</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">path</span><span class="p">,</span> <span class="s">"log_replicas"</span><span class="p">),</span>
          <span class="n">url</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">authentication</span><span class="p">,</span>
          <span class="n">flags</span><span class="p">.</span><span class="n">log_auto_initialize</span><span class="p">,</span>
          <span class="s">"registrar/"</span><span class="p">);</span>

<span class="p">...</span>
    <span class="n">storage</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LogStorage</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">LogStorage</code> 定义在 <code class="highlighter-rouge">include/mesos/state/log.hpp</code> 中：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Forward declarations.
</span><span class="k">class</span> <span class="nc">LogStorageProcess</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">LogStorage</span> <span class="o">:</span> <span class="k">public</span> <span class="n">mesos</span><span class="o">::</span><span class="n">state</span><span class="o">::</span><span class="n">Storage</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">LogStorage</span><span class="p">(</span><span class="n">mesos</span><span class="o">::</span><span class="n">log</span><span class="o">::</span><span class="n">Log</span><span class="o">*</span> <span class="n">log</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">diffsBetweenSnapshots</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">virtual</span> <span class="o">~</span><span class="n">LogStorage</span><span class="p">();</span>

  <span class="c1">// Storage implementation.
</span>  <span class="k">virtual</span> <span class="n">process</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Option</span><span class="o">&lt;</span><span class="n">internal</span><span class="o">::</span><span class="n">state</span><span class="o">::</span><span class="n">Entry</span><span class="o">&gt;&gt;</span> <span class="n">get</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="n">process</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">set</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">internal</span><span class="o">::</span><span class="n">state</span><span class="o">::</span><span class="n">Entry</span><span class="o">&amp;</span> <span class="n">entry</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">UUID</span><span class="o">&amp;</span> <span class="n">uuid</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="n">process</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">expunge</span><span class="p">(</span><span class="k">const</span> <span class="n">internal</span><span class="o">::</span><span class="n">state</span><span class="o">::</span><span class="n">Entry</span><span class="o">&amp;</span> <span class="n">entry</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="n">process</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">names</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">LogStorageProcess</span><span class="o">*</span> <span class="n">process</span><span class="p">;</span>
<span class="p">};</span>

</code></pre>
</div>

<h2 id="tocAnchor-1-9">State</h2>

<p>创建一个 <code class="highlighter-rouge">state</code> 来记录状态:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  mesos::state::protobuf::State* state =
    new mesos::state::protobuf::State(storage);
  Registrar* registrar =
    new Registrar(flags, state, READONLY_HTTP_AUTHENTICATION_REALM);
</code></pre>
</div>

<p><code class="highlighter-rouge">state</code> 为分布式服务提供了类似 key/value 的数据存储服务。
数据都是带版本的，所以每次 <code class="highlighter-rouge">set</code> 操作只有在上一次 fetch 到现在都没有被修改过才会成功。
<code class="highlighter-rouge">state</code> 定义在 <code class="highlighter-rouge">include/mesos/state/state.hpp</code> 中：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// An abstraction of "state" (possibly between multiple distributed
// components) represented by "variables" (effectively key/value
// pairs). Variables are versioned such that setting a variable in the
// state will only succeed if the variable has not changed since last
// fetched. Varying implementations of state provide varying
// replicated guarantees.
//
// Note that the semantics of 'fetch' and 'store' provide
// atomicity. That is, you cannot store a variable that has changed
// since you did the last fetch. That is, if a store succeeds then no
// other writes have been performed on the variable since your fetch.
//
// Example:
//
//   Storage* storage = new ZooKeeperStorage();
//   State* state = new State(storage);
//   Future&lt;Variable&gt; variable = state-&gt;fetch("slaves");
//   std::string value = update(variable.value());
//   variable = variable.mutate(value);
//   state-&gt;store(variable);
</span>
<span class="p">...</span>
<span class="k">class</span> <span class="nc">State</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">State</span><span class="p">(</span><span class="n">Storage</span><span class="o">*</span> <span class="n">_storage</span><span class="p">)</span> <span class="o">:</span> <span class="n">storage</span><span class="p">(</span><span class="n">_storage</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">State</span><span class="p">()</span> <span class="p">{}</span>

  <span class="c1">// Returns a variable from the state, creating a new one if one
</span>  <span class="c1">// previously did not exist (or an error if one occurs).
</span>  <span class="n">process</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Variable</span><span class="o">&gt;</span> <span class="n">fetch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>

  <span class="c1">// Returns the variable specified if it was successfully stored in
</span>  <span class="c1">// the state, otherwise returns none if the version of the variable
</span>  <span class="c1">// was no longer valid, or an error if one occurs.
</span>  <span class="n">process</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Option</span><span class="o">&lt;</span><span class="n">Variable</span><span class="o">&gt;&gt;</span> <span class="n">store</span><span class="p">(</span><span class="k">const</span> <span class="n">Variable</span><span class="o">&amp;</span> <span class="n">variable</span><span class="p">);</span>

  <span class="c1">// Returns true if successfully expunged the variable from the state.
</span>  <span class="n">process</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">expunge</span><span class="p">(</span><span class="k">const</span> <span class="n">Variable</span><span class="o">&amp;</span> <span class="n">variable</span><span class="p">);</span>

  <span class="c1">// Returns the collection of variable names in the state.
</span>  <span class="n">process</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">names</span><span class="p">();</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="tocAnchor-1-10">创建 Master contendor 和 detector</h2>

<p>简单地说，Contender 负责选主，Detector 负责探测谁是主。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code>  <span class="n">MasterContender</span><span class="o">*</span> <span class="n">contender</span><span class="p">;</span>
  <span class="n">MasterDetector</span><span class="o">*</span> <span class="n">detector</span><span class="p">;</span>

  <span class="n">Try</span><span class="o">&lt;</span><span class="n">MasterContender</span><span class="o">*&gt;</span> <span class="n">contender_</span> <span class="o">=</span> <span class="n">MasterContender</span><span class="o">::</span><span class="n">create</span><span class="p">(</span>
      <span class="n">flags</span><span class="p">.</span><span class="n">zk</span><span class="p">,</span> <span class="n">flags</span><span class="p">.</span><span class="n">master_contender</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">contender_</span><span class="p">.</span><span class="n">isError</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">EXIT</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">)</span>
      <span class="o">&lt;&lt;</span> <span class="s">"Failed to create a master contender: "</span> <span class="o">&lt;&lt;</span> <span class="n">contender_</span><span class="p">.</span><span class="n">error</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">contender</span> <span class="o">=</span> <span class="n">contender_</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>

  <span class="n">Try</span><span class="o">&lt;</span><span class="n">MasterDetector</span><span class="o">*&gt;</span> <span class="n">detector_</span> <span class="o">=</span> <span class="n">MasterDetector</span><span class="o">::</span><span class="n">create</span><span class="p">(</span>
      <span class="n">flags</span><span class="p">.</span><span class="n">zk</span><span class="p">,</span> <span class="n">flags</span><span class="p">.</span><span class="n">master_detector</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">detector_</span><span class="p">.</span><span class="n">isError</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">EXIT</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">)</span>
      <span class="o">&lt;&lt;</span> <span class="s">"Failed to create a master detector: "</span> <span class="o">&lt;&lt;</span> <span class="n">detector_</span><span class="p">.</span><span class="n">error</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">detector</span> <span class="o">=</span> <span class="n">detector_</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>

</code></pre>
</div>

<h2 id="tocAnchor-1-11">初始化 Authorizer</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code>  <span class="p">...</span>
  <span class="n">authorizer</span> <span class="o">=</span> <span class="n">Authorizer</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">flags</span><span class="p">.</span><span class="n">acls</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
  <span class="p">...</span>
      <span class="n">authorizer_</span> <span class="o">=</span> <span class="n">authorizer</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>

    <span class="c1">// Set the authorization callbacks for libprocess HTTP endpoints.
</span>    <span class="c1">// Note that these callbacks capture `authorizer_.get()`, but the master
</span>    <span class="c1">// creates a copy of the authorizer during construction. Thus, if in the
</span>    <span class="c1">// future it becomes possible to dynamically set the authorizer, this would
</span>    <span class="c1">// break.
</span>    <span class="n">process</span><span class="o">::</span><span class="n">http</span><span class="o">::</span><span class="n">authorization</span><span class="o">::</span><span class="n">setCallbacks</span><span class="p">(</span>
        <span class="n">createAuthorizationCallbacks</span><span class="p">(</span><span class="n">authorizer_</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
</code></pre>
</div>

<h2 id="tocAnchor-1-12">设置 Slave removal rate limiter</h2>

<p>为了保证集群的稳定，可以设置 slave 不能以太快的速率被 remove 出集群。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Option</span><span class="o">&lt;</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">RateLimiter</span><span class="o">&gt;&gt;</span> <span class="n">slaveRemovalLimiter</span> <span class="o">=</span> <span class="n">None</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="p">.</span><span class="n">agent_removal_rate_limit</span><span class="p">.</span><span class="n">isSome</span><span class="p">())</span> <span class="p">{</span>
      <span class="p">...</span>
      <span class="n">slaveRemovalLimiter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RateLimiter</span><span class="p">(</span><span class="n">permits</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">duration</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
      <span class="p">...</span>
  <span class="p">}</span>
</code></pre>
</div>

<h2 id="tocAnchor-1-13">创建 master process</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code>  <span class="n">Master</span><span class="o">*</span> <span class="n">master</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">Master</span><span class="p">(</span>
      <span class="n">allocator</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span>
      <span class="n">registrar</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="n">files</span><span class="p">,</span>
      <span class="n">contender</span><span class="p">,</span>
      <span class="n">detector</span><span class="p">,</span>
      <span class="n">authorizer_</span><span class="p">,</span>
      <span class="n">slaveRemovalLimiter</span><span class="p">,</span>
      <span class="n">flags</span><span class="p">);</span>
<span class="p">...</span>
  <span class="n">process</span><span class="o">::</span><span class="n">spawn</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
  <span class="n">process</span><span class="o">::</span><span class="n">wait</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">());</span>
<span class="p">...</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">Master</code> 的构造函数定义在 <code class="highlighter-rouge">src/master/master.hpp</code> 和 <code class="highlighter-rouge">src/master/master.cpp</code> 中：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Master</span><span class="o">::</span><span class="n">Master</span><span class="p">(</span>
    <span class="n">Allocator</span><span class="o">*</span> <span class="n">_allocator</span><span class="p">,</span>
    <span class="n">Registrar</span><span class="o">*</span> <span class="n">_registrar</span><span class="p">,</span>
    <span class="n">Files</span><span class="o">*</span> <span class="n">_files</span><span class="p">,</span>
    <span class="n">MasterContender</span><span class="o">*</span> <span class="n">_contender</span><span class="p">,</span>
    <span class="n">MasterDetector</span><span class="o">*</span> <span class="n">_detector</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Option</span><span class="o">&lt;</span><span class="n">Authorizer</span><span class="o">*&gt;&amp;</span> <span class="n">_authorizer</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Option</span><span class="o">&lt;</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">RateLimiter</span><span class="o">&gt;&gt;&amp;</span> <span class="n">_slaveRemovalLimiter</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Flags</span><span class="o">&amp;</span> <span class="n">_flags</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">ProcessBase</span><span class="p">(</span><span class="s">"master"</span><span class="p">),</span>
    <span class="n">flags</span><span class="p">(</span><span class="n">_flags</span><span class="p">),</span>
    <span class="n">http</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
    <span class="n">allocator</span><span class="p">(</span><span class="n">_allocator</span><span class="p">),</span>
    <span class="n">registrar</span><span class="p">(</span><span class="n">_registrar</span><span class="p">),</span>
    <span class="n">files</span><span class="p">(</span><span class="n">_files</span><span class="p">),</span>
    <span class="n">contender</span><span class="p">(</span><span class="n">_contender</span><span class="p">),</span>
    <span class="n">detector</span><span class="p">(</span><span class="n">_detector</span><span class="p">),</span>
    <span class="n">authorizer</span><span class="p">(</span><span class="n">_authorizer</span><span class="p">),</span>
    <span class="n">frameworks</span><span class="p">(</span><span class="n">flags</span><span class="p">),</span>
    <span class="n">authenticator</span><span class="p">(</span><span class="n">None</span><span class="p">()),</span>
    <span class="n">metrics</span><span class="p">(</span><span class="k">new</span> <span class="n">Metrics</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)),</span>
    <span class="n">electedTime</span><span class="p">(</span><span class="n">None</span><span class="p">())</span>
<span class="p">{</span>
  <span class="n">slaves</span><span class="p">.</span><span class="n">limiter</span> <span class="o">=</span> <span class="n">_slaveRemovalLimiter</span><span class="p">;</span>

  <span class="c1">// NOTE: We populate 'info_' here instead of inside 'initialize()'
</span>  <span class="c1">// because 'StandaloneMasterDetector' needs access to the info.
</span>
  <span class="c1">// Master ID is generated randomly based on UUID.
</span>  <span class="n">info_</span><span class="p">.</span><span class="n">set_id</span><span class="p">(</span><span class="n">UUID</span><span class="o">::</span><span class="n">random</span><span class="p">().</span><span class="n">toString</span><span class="p">());</span>

  <span class="c1">// NOTE: Currently, we store ip in MasterInfo in network order,
</span>  <span class="c1">// which should be fixed. See MESOS-1201 for details.
</span>  <span class="c1">// TODO(marco): The ip, port, hostname fields above are
</span>  <span class="c1">//     being deprecated; the code should be removed once
</span>  <span class="c1">//     the deprecation cycle is complete.
</span>  <span class="n">info_</span><span class="p">.</span><span class="n">set_ip</span><span class="p">(</span><span class="n">self</span><span class="p">().</span><span class="n">address</span><span class="p">.</span><span class="n">ip</span><span class="p">.</span><span class="n">in</span><span class="p">().</span><span class="n">get</span><span class="p">().</span><span class="n">s_addr</span><span class="p">);</span>

  <span class="n">info_</span><span class="p">.</span><span class="n">set_port</span><span class="p">(</span><span class="n">self</span><span class="p">().</span><span class="n">address</span><span class="p">.</span><span class="n">port</span><span class="p">);</span>
  <span class="n">info_</span><span class="p">.</span><span class="n">set_pid</span><span class="p">(</span><span class="n">self</span><span class="p">());</span>
  <span class="n">info_</span><span class="p">.</span><span class="n">set_version</span><span class="p">(</span><span class="n">MESOS_VERSION</span><span class="p">);</span>
  <span class="p">...</span>
  <span class="n">info_</span><span class="p">.</span><span class="n">set_hostname</span><span class="p">(</span><span class="n">hostname</span><span class="p">);</span>

  <span class="c1">// This uses the new `Address` message in `MasterInfo`.
</span>  <span class="n">info_</span><span class="p">.</span><span class="n">mutable_address</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">set_ip</span><span class="p">(</span><span class="n">stringify</span><span class="p">(</span><span class="n">self</span><span class="p">().</span><span class="n">address</span><span class="p">.</span><span class="n">ip</span><span class="p">));</span>
  <span class="n">info_</span><span class="p">.</span><span class="n">mutable_address</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">set_port</span><span class="p">(</span><span class="n">self</span><span class="p">().</span><span class="n">address</span><span class="p">.</span><span class="n">port</span><span class="p">);</span>
  <span class="n">info_</span><span class="p">.</span><span class="n">mutable_address</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">set_hostname</span><span class="p">(</span><span class="n">hostname</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>主要工作就是把一些信息存到 <code class="highlighter-rouge">info_</code> 中，<code class="highlighter-rouge">info_</code> 的类型是 <code class="highlighter-rouge">MasterInfo</code>。</p>

<p>接下来，开始 master process 的初始化。</p>

  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">做美好的人，做酷的事</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              做美好的人，做酷的事
            
            </li>
            
            <li><a href="mailto:gaopenghigh@gmail.com">gaopenghigh@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/gaopenghigh"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">gaopenghigh</span></a>

          </li>
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>记录所学所想
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
